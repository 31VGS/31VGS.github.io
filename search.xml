<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang搭建server/client通信</title>
      <link href="/2023/08/07/%E9%A1%B9%E7%9B%AE/go/"/>
      <url>/2023/08/07/%E9%A1%B9%E7%9B%AE/go/</url>
      
        <content type="html"><![CDATA[<h1 id="golang搭建server-x2F-client通信"><a href="#golang搭建server-x2F-client通信" class="headerlink" title="golang搭建server&#x2F;client通信"></a>golang搭建server&#x2F;client通信</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">HeartbeatTimeout = <span class="number">3</span> <span class="comment">// 心跳超时时间（秒）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ln, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8888&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to start server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Server started, waiting for connections...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := ln.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to accept connection:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Client connected:&quot;</span>, conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置心跳计时器</span></span><br><span class="line">heartbeatTimer := time.NewTimer(time.Second * HeartbeatTimeout)</span><br><span class="line"><span class="keyword">defer</span> heartbeatTimer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置读取超时时间</span></span><br><span class="line">conn.SetReadDeadline(time.Now().Add(time.Second * HeartbeatTimeout))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续三次心跳丢失计数</span></span><br><span class="line">missedHeartbeats := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 读取请求</span></span><br><span class="line"><span class="keyword">var</span> req Request</span><br><span class="line">err := json.NewDecoder(conn).Decode(&amp;req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to read request:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置读取超时时间</span></span><br><span class="line">conn.SetReadDeadline(time.Now().Add(time.Second * HeartbeatTimeout))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> req.Message == <span class="string">&quot;ping&quot;</span> &#123;</span><br><span class="line"><span class="comment">// 收到心跳消息，重置心跳计时器和丢失计数</span></span><br><span class="line">heartbeatTimer.Reset(time.Second * HeartbeatTimeout)</span><br><span class="line">missedHeartbeats = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应</span></span><br><span class="line">res := Response&#123;</span><br><span class="line">Message: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := json.NewEncoder(conn).Encode(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to send response:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 非心跳消息，处理业务逻辑</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Received message:&quot;</span>, req.Message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应</span></span><br><span class="line">res := Response&#123;</span><br><span class="line">Message: <span class="string">&quot;Hello, client!&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := json.NewEncoder(conn).Encode(res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to send response:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听心跳计时器和丢失计数</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-heartbeatTimer.C:</span><br><span class="line">missedHeartbeats++</span><br><span class="line"><span class="keyword">if</span> missedHeartbeats &gt;= <span class="number">3</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Heartbeat lost. Closing connection:&quot;</span>, conn.RemoteAddr())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ServerAddr = <span class="string">&quot;localhost:8888&quot;</span> <span class="comment">// 服务器地址</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, ServerAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to connect to server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Connected to server:&quot;</span>, ServerAddr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 发送心跳消息</span></span><br><span class="line">req := Request&#123;</span><br><span class="line">Message: <span class="string">&quot;ping&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">err := json.NewEncoder(conn).Encode(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to send request:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置读取超时时间</span></span><br><span class="line">conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取响应</span></span><br><span class="line"><span class="keyword">var</span> res Response</span><br><span class="line">err = json.NewDecoder(conn).Decode(&amp;res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to read response:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.Message == <span class="string">&quot;pong&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Received heartbeat from server&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Received消息:&quot;</span>, res.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux学习笔记</title>
      <link href="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="linux学习笔记"><a href="#linux学习笔记" class="headerlink" title="linux学习笔记"></a>linux学习笔记</h1><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://www.runoob.com/w3cnote/linux-common-command-2.html">常用命令</a></p><p><a href="https://www.runoob.com/linux/linux-command-manual.html">全部命令</a></p><h3 id="查看-ls"><a href="#查看-ls" class="headerlink" title="查看 ls"></a>查看 ls</h3><p>常用参数搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class="line">ls -A 列出除.及..的其它文件</span><br><span class="line">ls -r 反序排列</span><br><span class="line">ls -t 以文件修改时间排序</span><br><span class="line">ls -S 以文件大小排序</span><br><span class="line">ls -h 以易读大小显示</span><br><span class="line">ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure><p>列出当前目录中所有以”t”开头的目录的详细内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure><p>列出文件绝对路径（不包含隐藏文件）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls | sed &quot;s:^:`pwd`/:&quot;</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711225554579.png" alt="image-20230711225554579"></p><p>列出文件绝对路径（包含隐藏文件）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find $pwd -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure><h3 id="切换-cd"><a href="#切换-cd" class="headerlink" title="切换 cd"></a>切换 cd</h3><p>进入要目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><p>进入 “home” 目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>进入上一次工作路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p>把上个命令的参数作为cd参数使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure><h3 id="查看当前工作目录路径-pwd"><a href="#查看当前工作目录路径-pwd" class="headerlink" title="查看当前工作目录路径 pwd"></a>查看当前工作目录路径 pwd</h3><p>查看软链接的实际路径</p><p>pwd -P</p><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711225650269.png" alt="image-20230711225650269"></p><h3 id="创建文件夹-mkdir"><a href="#创建文件夹-mkdir" class="headerlink" title="创建文件夹 mkdir"></a>创建文件夹 mkdir</h3><p>常用参数搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -m 设置存取权限</span><br><span class="line">mkdir -p 路径名称,即一次可以建立多个目录</span><br></pre></td></tr></table></figure><p> tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /tmp/test/t1/t</span><br></pre></td></tr></table></figure><h3 id="删除-rm"><a href="#删除-rm" class="headerlink" title="删除 rm"></a>删除 rm</h3><p>常用参数搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 删除前逐一询问确认。</span><br><span class="line">-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</span><br><span class="line">-r 将目录及以下之档案亦逐一删除。</span><br></pre></td></tr></table></figure><p>rmdir</p><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p><p><strong>注意：不能删除非空目录</strong></p><p>当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir -p parent/child/child11</span><br></pre></td></tr></table></figure><h3 id="移动或修改-mv"><a href="#移动或修改-mv" class="headerlink" title="移动或修改 mv"></a>移动或修改 mv</h3><p>常用参数搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</span><br><span class="line">-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</span><br><span class="line">-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</span><br><span class="line">-n: 不要覆盖任何已存在的文件或目录。</span><br><span class="line">-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">命令格式</th><th align="left">运行结果</th></tr></thead><tbody><tr><td align="left"><code>mv source_file(文件) dest_file(文件)</code></td><td align="left">将源文件名 source_file 改为目标文件名 dest_file</td></tr><tr><td align="left"><code>mv source_file(文件) dest_directory(目录)</code></td><td align="left">将文件 source_file 移动到目标目录 dest_directory 中</td></tr><tr><td align="left"><code>mv source_directory(目录) dest_directory(目录)</code></td><td align="left">目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td></tr><tr><td align="left"><code>mv source_directory(目录) dest_file(文件)</code></td><td align="left">出错</td></tr></tbody></table><h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 cp</h3><p>常用参数搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-i 提示</span><br><span class="line">-r 复制目录及目录内所有项目</span><br><span class="line">-a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure><p>复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -ai a.txt test</span><br></pre></td></tr></table></figure><p>为 a.txt 建立一个链接（快捷方式）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -s a.txt link_a.txt</span><br></pre></td></tr></table></figure><h3 id="显示-创建文件-合并文件-cat"><a href="#显示-创建文件-合并文件-cat" class="headerlink" title="显示 创建文件 合并文件 cat"></a>显示 创建文件 合并文件 cat</h3><ol><li>一次显示整个文件:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure><ol start="2"><li>从键盘创建一个文件:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure><p>只能创建新文件，不能编辑已有文件。</p><ol start="3"><li>将几个文件合并为一个文件:</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure><ul><li>-b 对非空输出行号</li><li>-n 输出所有行号</li><li><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230711231613355.png" alt="image-20230711231613355"></li></ul><h3 id="逐页阅读-more"><a href="#逐页阅读-more" class="headerlink" title="逐页阅读 more"></a>逐页阅读 more</h3><p><strong>常用命令参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+n      从笫 n 行开始显示</span><br><span class="line">-n       定义屏幕大小为n行</span><br><span class="line">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c       从顶部清屏，然后显示</span><br><span class="line">-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l        忽略Ctrl+l（换页）字符</span><br><span class="line">-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s       把连续的多个空行显示为一行</span><br><span class="line">-u       把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure><p><strong>常用操作命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter    向下 n 行，需要定义。默认为 1 行</span><br><span class="line">Ctrl+F   向下滚动一屏</span><br><span class="line">空格键  向下滚动一屏</span><br><span class="line">Ctrl+B  返回上一屏</span><br><span class="line">=       输出当前行的行号</span><br><span class="line">:f     输出文件名和当前行的行号</span><br><span class="line">V      调用vi编辑器</span><br><span class="line">!命令   调用Shell，并执行命令</span><br><span class="line">q       退出more</span><br></pre></td></tr></table></figure><h4 id="随意浏览文件-less"><a href="#随意浏览文件-less" class="headerlink" title="随意浏览文件 less"></a>随意浏览文件 less</h4><h4 id="显示开头（默认前十行）-head"><a href="#显示开头（默认前十行）-head" class="headerlink" title="显示开头（默认前十行） head"></a>显示开头（默认前十行） head</h4><h4 id="显示末尾（常用于日志）-tail"><a href="#显示末尾（常用于日志）-tail" class="headerlink" title="显示末尾（常用于日志） tail"></a>显示末尾（常用于日志） tail</h4><h3 id="搜索-which"><a href="#搜索-which" class="headerlink" title="搜索 which"></a>搜索 which</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which     查看可执行文件的位置。</span><br><span class="line">whereis 查看文件的位置。</span><br><span class="line">locate  配合数据库查看文件位置。</span><br><span class="line">find        实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure><h3 id="改变访问权限-chmod"><a href="#改变访问权限-chmod" class="headerlink" title="改变访问权限 chmod"></a>改变访问权限 chmod</h3><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 当发生改变时，报告处理信息</span><br><span class="line">-R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure><p>权限范围：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u ：目录或者文件的当前的用户</span><br><span class="line">g ：目录或者文件的当前的群组</span><br><span class="line">o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">a ：所有的用户及群组</span><br></pre></td></tr></table></figure><p>权限代号：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r ：读权限，用数字4表示</span><br><span class="line">w ：写权限，用数字2表示</span><br><span class="line">x ：执行权限，用数字1表示</span><br><span class="line">- ：删除权限，用数字0表示</span><br><span class="line">s ：特殊权限</span><br></pre></td></tr></table></figure><h3 id="解压缩-tar"><a href="#解压缩-tar" class="headerlink" title="解压缩 tar"></a>解压缩 tar</h3><p>打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 建立新的压缩文件</span><br><span class="line">-f 指定压缩文件</span><br><span class="line">-r 添加文件到已经压缩文件包中</span><br><span class="line">-u 添加改了和现有的文件到压缩包中</span><br><span class="line">-x 从压缩包中抽取文件</span><br><span class="line">-t 显示压缩文件中的内容</span><br><span class="line">-z 支持gzip压缩</span><br><span class="line">-j 支持bzip2压缩</span><br><span class="line">-Z 支持compress解压文件</span><br><span class="line">-v 显示操作过程</span><br></pre></td></tr></table></figure><p>将文件全部打包成 tar 包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</span><br></pre></td></tr></table></figure><p>将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvf /tmp/etc.tar.gz /etc</span><br></pre></td></tr></table></figure><h3 id="更改拥有者-chown"><a href="#更改拥有者-chown" class="headerlink" title="更改拥有者 chown"></a>更改拥有者 chown</h3><h3 id="显示磁盘使用情况-df"><a href="#显示磁盘使用情况-df" class="headerlink" title="显示磁盘使用情况 df"></a>显示磁盘使用情况 df</h3><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a 全部文件系统列表</span><br><span class="line">-h 以方便阅读的方式显示信息</span><br><span class="line">-i 显示inode信息</span><br><span class="line">-k 区块为1024字节</span><br><span class="line">-l 只显示本地磁盘</span><br><span class="line">-T 列出文件系统类型</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712213239660.png" alt="image-20230712213239660"></p><p>查看文件使用空间 du</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du [选项] [文件]</span><br></pre></td></tr></table></figure><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a 显示目录中所有文件大小</span><br><span class="line">-k 以KB为单位显示文件大小</span><br><span class="line">-m 以MB为单位显示文件大小</span><br><span class="line">-g 以GB为单位显示文件大小</span><br><span class="line">-h 以易读方式显示文件大小</span><br><span class="line">-s 仅显示总计</span><br><span class="line">-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712213417292.png" alt="image-20230712213417292"></p><h3 id="建立链接-ln"><a href="#建立链接-ln" class="headerlink" title="建立链接 ln"></a>建立链接 ln</h3><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p><p>链接分类：软件链接及硬链接</p><p>软链接：</p><ul><li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li><li>2.软链接可以 跨文件系统 ，硬链接不可以</li><li>3.软链接可以对一个不存在的文件名进行链接</li><li>4.软链接可以对目录进行链接</li></ul><p>硬链接:</p><ul><li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>2.不允许给目录创建硬链接</li><li>3.硬链接只有在同一个文件系统中才能创建</li></ul><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-s 软链接（符号链接）</span><br><span class="line">-v 显示详细处理过程</span><br></pre></td></tr></table></figure><h3 id="时间-date"><a href="#时间-date" class="headerlink" title="时间 date"></a>时间 date</h3><p>显示或设定系统的日期与时间。</p><p>命令参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class="line">-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class="line">-u 　显示GMT。</span><br><span class="line">%H 小时(00-23)</span><br><span class="line">%I 小时(00-12)</span><br><span class="line">%M 分钟(以00-59来表示)</span><br><span class="line">%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。</span><br><span class="line">%S 秒(以本地的惯用法来表示)</span><br><span class="line">%a 星期的缩写。</span><br><span class="line">%A 星期的完整名称。</span><br><span class="line">%d 日期(以01-31来表示)。</span><br><span class="line">%D 日期(含年月日)。</span><br><span class="line">%m 月份(以01-12来表示)。</span><br><span class="line">%y 年份(以00-99来表示)。</span><br><span class="line">%Y 年份(以四位数来表示)。</span><br></pre></td></tr></table></figure><h3 id="文本搜索-grep"><a href="#文本搜索-grep" class="headerlink" title="文本搜索 grep"></a>文本搜索 grep</h3><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p><p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [option] pattern file|dir</span><br></pre></td></tr></table></figure><p>常用参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A n --after-context显示匹配字符后n行</span><br><span class="line">-B n --before-context显示匹配字符前n行</span><br><span class="line">-C n --context 显示匹配字符前后n行</span><br><span class="line">-c --count 计算符合样式的列数</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-l 只列出文件内容符合指定的样式的文件名称</span><br><span class="line">-f 从文件中读取关键词</span><br><span class="line">-n 显示匹配内容的所在文件中行数</span><br><span class="line">-R 递归查找文件夹</span><br></pre></td></tr></table></figure><p>查找指定进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep svn</span><br></pre></td></tr></table></figure><p>查找指定进程个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep svn -c</span><br></pre></td></tr></table></figure><p>从文件中读取关键词</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat test1.txt | grep -f key.log</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712213744898.png" alt="image-20230712213744898"></p><h3 id="统计-wc"><a href="#统计-wc" class="headerlink" title="统计 wc"></a>统计 wc</h3><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc [option] file..</span><br></pre></td></tr></table></figure><p><strong>命令参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 统计字节数</span><br><span class="line">-l 统计行数</span><br><span class="line">-m 统计字符数</span><br><span class="line">-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><p>查找文件的 行数 单词数 字节数 文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc text.txt</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712213838554.png" alt="image-20230712213838554"></p><h3 id="查看进程-ps"><a href="#查看进程-ps" class="headerlink" title="查看进程 ps"></a>查看进程 ps</h3><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p><p>linux上进程有5种状态:</p><ul><li><ol><li>运行(正在运行或在运行队列中等待)</li></ol></li><li><ol start="2"><li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li></ol></li><li><ol start="3"><li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li></ol></li><li><ol start="4"><li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li></ol></li><li><ol start="5"><li>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</li></ol></li></ul><p>ps 工具标识进程的5种状态码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D 不可中断 uninterruptible sleep (usually IO)</span><br><span class="line">R 运行 runnable (on run queue)</span><br><span class="line">S 中断 sleeping</span><br><span class="line">T 停止 traced or stopped</span><br><span class="line">Z 僵死 a defunct (”zombie”) process</span><br></pre></td></tr></table></figure><p><strong>命令参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A 显示所有进程</span><br><span class="line">a 显示所有进程</span><br><span class="line">-a 显示同一终端下所有进程</span><br><span class="line">c 显示进程真实名称</span><br><span class="line">e 显示环境变量</span><br><span class="line">f 显示进程间的关系</span><br><span class="line">r 显示当前终端运行的进程</span><br><span class="line">-aux 显示所有包含其它使用的进程</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712213940007.png" alt="image-20230712213940007"></p><h3 id="显示进程详细信息-top"><a href="#显示进程详细信息-top" class="headerlink" title="显示进程详细信息 top"></a>显示进程详细信息 top</h3><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 显示完整的进程命令</span><br><span class="line">-s 保密模式</span><br><span class="line">-p &lt;进程号&gt; 指定进程显示</span><br><span class="line">-n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712214058870.png" alt="image-20230712214058870"></p><h3 id="结束进程-kill"><a href="#结束进程-kill" class="headerlink" title="结束进程 kill"></a>结束进程 kill</h3><p>发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><p><strong>常用参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line">-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line">-s  指定发送信号</span><br><span class="line">-u  指定用户</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><p>先使用ps查找进程pro1，然后用kill杀掉</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 $(ps -ef | grep pro1)</span><br></pre></td></tr></table></figure><h3 id="显示内存-free"><a href="#显示内存-free" class="headerlink" title="显示内存 free"></a>显示内存 free</h3><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p><p><strong>命令参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b 以Byte显示内存使用情况</span><br><span class="line">-k 以kb为单位显示内存使用情况</span><br><span class="line">-m 以mb为单位显示内存使用情况</span><br><span class="line">-g 以gb为单位显示内存使用情况</span><br><span class="line">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="line">-t 显示内存使用总合</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><p>显示内存使用情况</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free</span><br><span class="line">free -k</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><p><img src="/2023/07/12/%E7%AC%94%E8%AE%B0/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230712214250644.png" alt="image-20230712214250644"></p><h2 id="shell脚本教程"><a href="#shell脚本教程" class="headerlink" title="shell脚本教程"></a>shell脚本教程</h2><h3 id="参考网站-1"><a href="#参考网站-1" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://www.runoob.com/linux/linux-shell.html">shell详细教程</a></p><p><a href="https://www.runoob.com/w3cnote/shell-quick-start.html">shell快速入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2023/07/01/%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/01/%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h1><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>猴子都能懂的GIT入门</p><p><a href="https://backlog.com/git-tutorial/cn/intro/intro1_2.html">https://backlog.com/git-tutorial/cn/intro/intro1_2.html</a></p><p><a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></p><p><a href="https://www.runoob.com/w3cnote/git-gui-window.html">https://www.runoob.com/w3cnote/git-gui-window.html</a></p><p><a href="https://blog.csdn.net/qq_35246620/article/details/66973794">https://blog.csdn.net/qq_35246620/article/details/66973794</a></p><h2 id="git学习路线及笔记"><a href="#git学习路线及笔记" class="headerlink" title="git学习路线及笔记"></a>git学习路线及笔记</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。</p><p>Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="提交信息格式"><a href="#提交信息格式" class="headerlink" title="提交信息格式"></a>提交信息格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure><h4 id="工作树和指引"><a href="#工作树和指引" class="headerlink" title="工作树和指引"></a>工作树和指引</h4><p><img src="/2023/07/01/%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/capture_intro1_4_1.png" alt="工作树和索引"></p><p>Git在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库。因此，要提交文件，首先需要把文件加入到索引区域中。</p><h4 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h4><p><img src="/2023/07/01/%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git-process.png" alt="img"></p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>git init初始化仓库</p><p>git clone <repo> <directory>拷贝一份远程仓库，也就是下载一个项目。</directory></repo></p><p>​ex:克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git （可自命名）</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>git add</code></td><td align="center">添加文件到暂存区</td></tr><tr><td align="center"><code>git status</code></td><td align="center">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="center"><code>git diff</code></td><td align="center">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="center"><code>git commit</code></td><td align="center">提交暂存区到本地仓库。</td></tr><tr><td align="center"><code>git reset</code></td><td align="center">回退版本。</td></tr><tr><td align="center"><code>git rm</code></td><td align="center">将文件从暂存区和工作区中删除。</td></tr><tr><td align="center"><code>git mv</code></td><td align="center">移动或重命名工作区文件。</td></tr><tr><td align="center"><code>git log</code></td><td align="center">查看历史提交记录</td></tr><tr><td align="center"><code>git blame &lt;file&gt;</code></td><td align="center">以列表形式查看指定文件的历史修改记录</td></tr><tr><td align="center"><code>git remote</code></td><td align="center">远程仓库操作</td></tr><tr><td align="center"><code>git fetch</code></td><td align="center">从远程获取代码库</td></tr><tr><td align="center"><code>git pull</code></td><td align="center">下载远程代码并合并</td></tr><tr><td align="center"><code>git push</code></td><td align="center">上传远程代码并合并</td></tr></tbody></table><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>创建分支</p><p>​git branch (branchname)</p><p>切换分支命令:</p><p>​git checkout (branchname)</p><p>合并分支命令:</p><p>​git merge </p><p>列出分支基本命令：</p><p>​git branch</p><p>删除分支命令：</p><p>​git branch -d (branchname)</p><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>还是git gui好用</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Auto.js实现的起点读书自动化签到系统</title>
      <link href="/2023/02/25/%E9%A1%B9%E7%9B%AE/Autojd/"/>
      <url>/2023/02/25/%E9%A1%B9%E7%9B%AE/Autojd/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Auto-js实现的起点读书自动化签到系统"><a href="#基于Auto-js实现的起点读书自动化签到系统" class="headerlink" title="基于Auto.js实现的起点读书自动化签到系统"></a>基于Auto.js实现的起点读书自动化签到系统</h1><p>众所周知，起点app端的充值币是十分昂贵的，而其独有的签到系统可以每天为我们提供50币的额度，但是要求连续观看8个广告每个50秒。对于这种简单无脑的工作自然是选择手机自动化更为方便<br>但是为了保证手机的安全性，当然是自己写的脚本更为安全啦，所以在查找一众资料后，我选择了使用Auto.js这一自动化工具实现功能。</p><h2 id="什么是Auto-js"><a href="#什么是Auto-js" class="headerlink" title="什么是Auto.js"></a>什么是Auto.js</h2><p>Auto.JS是Android平台上的JavaScript自动化工具。</p><p>它的本质是可执行自己编写的简易Javascript脚本的，尤其可以在开启“无障碍模式”的情况下对其他App进行一些操作的一个Android App，便于进行自动化操作。学习成本非常低。</p><p>Auto.JS已被黑产广泛使用，以至于作者关闭了官方下载通道。</p><p>而其新版AutoPro需要49元的一次性买断也对我们这种第一次尝试的用户增加了负担，所以可以先试用这个老版的，用的多了还是建议大家使用功能更加完善的新版AutoPro。<br><a href="https://github.com/ji4ozhu/Auto.js4.1.1">https://github.com/ji4ozhu/Auto.js4.1.1</a></p><h3 id="可以做的事情"><a href="#可以做的事情" class="headerlink" title="可以做的事情"></a>可以做的事情</h3><ol><li>数据监控：可以监视当前手机的数据。</li><li>图片监控：截图获取当前页面信息。</li><li>控件操作：模拟操作手机控件。</li><li>自动化工作流：编写简单的脚本，完成一系列自动化操作。如：微信自动点赞，快速抢单等。</li><li>定时功能：定时执行某个脚本，来完成定时任务。如：定时打卡签到等。</li></ol><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>项目地址：<a href="https://github.com/hyb1996/Auto.js">https://github.com/hyb1996/Auto.js</a><br>官方论坛：<a href="https://www.autojs.org/">https://www.autojs.org/</a><br>在线文档：<a href="https://hyb1996.github.io/AutoJs-Docs/#/">https://hyb1996.github.io/AutoJs-Docs/#/</a><br>简介：一个支持无障碍服务的Android平台上的Javascript IDE,其发展目标是JsBox和Workflow。<br>主要功能：由无障碍服务实现的简单易用的自动操作函数<br>协议：基于Mozilla Public License Version 2.0</p><h3 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h3><p>提倡自动动手编写Auto.JS脚本</p><ul><li>安全：使用权限问题，使得Auto.js运行的脚本拥有较大的权限，使用他人的脚本可能存在风险。</li><li>编写简单：JS 脚本嵌套中文，方便阅读和书写。</li><li>脚本升级：应用升级需要自己升级脚本；脚本bug自己解决。</li><li>获得技能。</li></ul><h2 id="安装auto-js"><a href="#安装auto-js" class="headerlink" title="安装auto.js"></a>安装auto.js</h2><p>安装手机端APP<br><a href="https://github.com/ji4ozhu/Auto.js4.1.1">https://github.com/ji4ozhu/Auto.js4.1.1</a><br>首先安装VSCode，在VS Code中菜单”查看”-&gt;”扩展”-&gt;输入”Auto.js”或”hyb1996”搜索，即可看到”Auto.js-VSCodeExt”插件，安装即可。请把文件保存为.js，方便代码补全。<br><img src="/img/block/Autojs/1413364-c9792db048eb45b9.jpg"><br>打开无障碍 悬浮窗权限 输入电脑IP连接<br><img src="/img/block/Autojs/pp5j2qhtkc.png"></p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>做好准备工作我们就可以开始编写脚本了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toastLog</span>(<span class="string">&#x27;即将开始起点读书自动签到功能&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="title function_">auto</span>();<span class="comment">//授权auto.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> 进入界面() &#123;</span><br><span class="line">    <span class="title function_">home</span>();</span><br><span class="line">    <span class="comment">// click(770, 1700);</span></span><br><span class="line">    <span class="comment">// sleep(1000);</span></span><br><span class="line">    <span class="title function_">launchApp</span>(<span class="string">&quot;起点读书&quot;</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="title function_">click</span>(<span class="number">1067</span>, <span class="number">2462</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="title function_">click</span>(<span class="number">325</span>, <span class="number">1150</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> 领取奖励() &#123;</span><br><span class="line">    <span class="title function_">click</span>(<span class="number">615</span>, <span class="number">1540</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">click</span>(<span class="number">90</span>, <span class="number">160</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">click</span>(<span class="number">617</span>, <span class="number">1654</span>);</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">进入界面();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">    领取奖励();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">exit</span>();</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接着我们使用控制面板，调用auto.js:run即可开始脚本<br>最后保存到手机端便大功告成了<br><img src="/img/block/Autojs/Screenshot_2023-02-25-21-00-04-801_com.qidian.QDR.jpg"></p><h2 id="附录资料"><a href="#附录资料" class="headerlink" title="附录资料"></a>附录资料</h2><p>全局</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">waitForPackage</span>(package[, period = <span class="number">200</span>])<span class="comment">//等待指定的应用出现。</span></span><br><span class="line"><span class="title function_">waitForPackage</span>(<span class="string">&quot;com.tencent.mm&quot;</span>)<span class="comment">//例如等待当前界面为微信</span></span><br><span class="line"><span class="title function_">waitForActivity</span>(activity[, period = <span class="number">200</span>])<span class="comment">//等待指定的Activity出现，period为检查Activity的间隔。</span></span><br><span class="line"><span class="title function_">waitForActivity</span>(<span class="string">&quot;com.ss.android.ugc.aweme.following.ui.FollowRelationTabActivity&quot;</span>)<span class="comment">//等待抖音其他用户的关注列表页面出现：</span></span><br><span class="line"><span class="title function_">sleep</span>(n)<span class="comment">//毫秒数</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&quot;message&quot;</span>)<span class="comment">//打印日志</span></span><br><span class="line"><span class="title function_">toast</span>(<span class="string">&quot;message&quot;</span>)<span class="comment">//气泡提示</span></span><br><span class="line"><span class="title function_">toastLog</span>(<span class="string">&quot;message&quot;</span>)<span class="comment">//打印日志并气泡提示</span></span><br><span class="line"><span class="title function_">setClip</span>(<span class="string">&quot;text&quot;</span>)<span class="comment">//设置剪贴板内容</span></span><br><span class="line"><span class="title function_">exit</span>()<span class="comment">//立即停止脚本运行</span></span><br><span class="line"><span class="title function_">random</span>(min, max)<span class="comment">//随机数</span></span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">launch</span>(<span class="string">&quot;包名&quot;</span>)<span class="comment">//通过包名启动应用</span></span><br><span class="line"><span class="title function_">launchPackage</span>(<span class="string">&quot;包名&quot;</span>)<span class="comment">//通过包名启动应用</span></span><br><span class="line"><span class="title function_">launchApp</span>(appName)<span class="comment">//通过名称启动应用</span></span><br><span class="line"><span class="title function_">getPackageName</span>(appName)<span class="comment">//获取应用名称对应的已安装的应用的包名</span></span><br><span class="line"><span class="title function_">getAppName</span>(<span class="string">&quot;包名&quot;</span>)<span class="comment">//获取应用包名对应的已安装的应用的名称</span></span><br><span class="line">app.<span class="title function_">openAppSetting</span>(<span class="string">&quot;包名&quot;</span>)<span class="comment">//打开应用的详情页(设置页)。返回false; 否则返回true(全局)</span></span><br><span class="line">app.<span class="title function_">editFile</span>(<span class="string">&quot;/sdcard/1.txt/);//用其他应用编辑文件文本文件</span></span><br><span class="line"><span class="string">app.uninstall(&quot;</span>com.<span class="property">tencent</span>.<span class="property">mobileqq</span><span class="string">&quot;);//卸载应用</span></span><br><span class="line"><span class="string">app.openUrl(&quot;</span>包名<span class="string">&quot;);//浏览器打开网站，Url，如果不以&quot;</span><span class="attr">http</span>:<span class="comment">//&quot;或&quot;https://“开头则默认是&quot;http://”</span></span><br></pre></td></tr></table></figure><p>坐标</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setScreenMetrics</span>(width, height)在width*height的设备中，坐标操作自适应</span><br><span class="line">width &#123;number&#125; <span class="comment">//屏幕宽度，单位像素</span></span><br><span class="line">height &#123;number&#125; <span class="comment">//屏幕高度，单位像素</span></span><br><span class="line"><span class="title function_">click</span>(x, y)<span class="comment">//点击</span></span><br><span class="line"><span class="title function_">longClick</span>(x, y)<span class="comment">//长按</span></span><br><span class="line"><span class="title function_">press</span>(x, y, duration)<span class="comment">//按住</span></span><br><span class="line"><span class="title function_">swipe</span>(x1, y1, x2, y2, duration)<span class="comment">//滑动</span></span><br><span class="line"><span class="title function_">swipeEx</span>(x1, y1, x2, y2, duration)<span class="comment">//仿真随机曲线滑动</span></span><br><span class="line"><span class="title function_">gesture</span>(duration, [x1, y1], [x2, y2], …)<span class="comment">//手势路径，时长2s</span></span><br><span class="line"><span class="title function_">gestures</span>([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …)<span class="comment">//延时多点手势路径</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3b24656b22c9">https://www.jianshu.com/p/3b24656b22c9</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatGPT注册流程及使用指导</title>
      <link href="/2023/02/19/%E9%A1%B9%E7%9B%AE/chatGPT/"/>
      <url>/2023/02/19/%E9%A1%B9%E7%9B%AE/chatGPT/</url>
      
        <content type="html"><![CDATA[<h1 id="chatGPT注册流程及使用指导"><a href="#chatGPT注册流程及使用指导" class="headerlink" title="chatGPT注册流程及使用指导"></a>chatGPT注册流程及使用指导</h1><p>最近chatGPT风头正盛，本篇文章旨在帮助无任何基础的小白使用chatGPT</p><h2 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h2><ol><li>切换外网环境，梯子就不多赘述，github上搜魔法就行(注：只能是外国，香港是不行滴)</li><li>进入<a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a> 用自己的邮箱注册并验证邮件</li><li>接下来是难倒很多人的一步需要验证一个国外的手机号，而这需要在这个网站充值1美金就可以使用好几次了（据说chatGPT太火还涨价了）<br><a href="https://sms-activate.org/cn/">https://sms-activate.org/cn/#</a></li><li>填写收到的验证码就注册成功了。然后就可以愉快地使用chatGPT了</li></ol><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>如果是想体会和人工智能聊天的乐趣，那么可以进入这个网站进行愉快地聊天，中文也没有任何问题。<br>    <a href="https://chat.openai.com/chat">https://chat.openai.com/chat</a><br>    <img src="/img/block/chatGpt/QQ%E6%88%AA%E5%9B%BE20230225213208.png"><br>但如果想体验更多的功能可以进入examples选择合适的模型，包括很多人期待的帮写论文和代码，以及写笑话和恐怖故事这样奇奇怪怪的功能。<br>    <a href="https://platform.openai.com/examples">https://platform.openai.com/examples</a><br>    <img src="/img/block/chatGpt/QQ%E6%88%AA%E5%9B%BE20230225213439.png"><br>接下来以论文为例讲下简单的参数调整，我们进入论文大纲<br>    <img src="/img/block/chatGpt/QQ%E6%88%AA%E5%9B%BE20230225214307.png"></p><ul><li>Model 表示你要选择的模型，以时间和准确度各不相同</li><li>Temperature 数值越高则越发散但可能不够准确，越低越准确但可能雷同没有新意</li><li>Maximum length 代表输出文字长度，但这个数字不是字数而是字符数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于机器学习的乳腺癌影像分析</title>
      <link href="/2023/01/02/%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%20(3)/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%20(3)/"/>
      <url>/2023/01/02/%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%20(3)/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%20(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="基于机器学习的乳腺癌影像分析"><a href="#基于机器学习的乳腺癌影像分析" class="headerlink" title="基于机器学习的乳腺癌影像分析"></a>基于机器学习的乳腺癌影像分析</h1><h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a><strong>异常检测</strong></h2><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a><strong>数据集划分</strong></h3><p>使用留出法，将1345个数据分出1000个训练集和345个测试集</p><p>训练集中良性占63％，恶性占37%</p><p>测试集中良性占79%，恶性占21%</p><p>训练集导出至train_data.csv</p><p>测试集导出至test_data.csv</p><table><thead><tr><th align="left"></th><th align="left"><strong>N（0，良性）</strong></th><th align="left"><strong>P（1，恶性）</strong></th></tr></thead><tbody><tr><td align="left">训练集</td><td align="left">634</td><td align="left">366</td></tr><tr><td align="left">测试集</td><td align="left">273</td><td align="left">72</td></tr></tbody></table><h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a><strong>DBSCAN</strong></h3><h4 id="思路及原理"><a href="#思路及原理" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>DBSCAN的算法步骤比较简单，主要分成两步。</p><h5 id="1、寻找核心点形成临时聚类簇"><a href="#1、寻找核心点形成临时聚类簇" class="headerlink" title="1、寻找核心点形成临时聚类簇"></a><strong>1、寻找核心点形成临时聚类簇</strong></h5><p>扫描全部样本点，如果某个样本点R半径范围内点数目&gt;&#x3D;MinPoints，则将其纳入核心点列表，并将其密度直达的点形成对应的临时聚类簇。</p><h5 id="2、合并临时聚类簇得到聚类簇"><a href="#2、合并临时聚类簇得到聚类簇" class="headerlink" title="2、合并临时聚类簇得到聚类簇"></a><strong>2、合并临时聚类簇得到聚类簇</strong></h5><p>对于每一个临时聚类簇，检查其中的点是否为核心点，如果是，将该点对应的临时聚类簇和当前临时聚类簇合并，得到新的临时聚类簇。</p><p>重复此操作，直到当前临时聚类簇中的每一个点要么不在核心点列表，要么其密度直达的点都已经在该临时聚类簇，该临时聚类簇升级成为聚类簇。</p><p>继续对剩余的临时聚类簇进行相同的合并操作，直到全部临时聚类簇被处理。反复寻找这些核心点直接密度可达或密度可达的点，将其加入到相应的类，对于核心点发生密度可达状况的类，给予合并</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.001.png" alt="DFZIMAYBYY"></p><p>DBSCAN算法可以抽象为以下几步：</p><p>1）找到每个样本的邻域内的样本个数，若个数大于等于MinPts，则该样本为核心点；</p><p>2）找到每个核心样本密度直达和密度可达的样本，且该样本亦为核心样本，忽略所有的非核心样本；</p><p>3）若非核心样本在核心样本的邻域内，则非核心样本为边界样本，反之为噪声。</p><p>使用轮廓系数作为判断聚类好坏的依据</p><p><a href="https://so.csdn.net/so/search?q=%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0&spm=1001.2101.3001.7020">轮廓系数</a>（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。</p><p><code>         </code><strong>方法：</strong></p><p><code>                  </code>1，计算样本i到同簇其他样本的平均距离ai。ai 越小，说明样本i越应该被聚类到该簇。将ai 称为样本i的<strong>簇内不相似度</strong>。</p><p><code>                            </code><strong>簇C中所有样本的a i 均值称为簇C的簇不相似度。</strong></p><p><code>                  </code>2，计算样本i到其他某簇Cj 的所有样本的平均距离bij，称为样本i与簇Cj 的不相似度。定义为样本i的<strong>簇间不相似度</strong>：bi &#x3D;min{bi1, bi2, …, bik}</p><p><code>                            </code><strong>bi越大，说明样本i越不属于其他簇。</strong></p><p><code>                   </code>3，根据样本i的簇内不相似度a i 和簇间不相似度b i ，定义样本i的<strong>轮廓系数</strong>：</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.002.png" alt="NNZYMAYA24"></p><p><code>                   </code>4，判断：</p><p><code>                            </code>si接近1，则说明样本i聚类合理；</p><p><code>                            </code>si接近-1，则说明样本i更应该分类到另外的簇；</p><p><code>                            </code>若si 近似为0，则说明样本i在两个簇的边界上。</p><p><code>         </code><strong>所有样本的s i 的均值称为聚类结果的轮廓系数，是该聚类是否合理、有效的度量。</strong></p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><p>分别对良性和恶性样本分别进行DBSCAN聚类分析，以下以良性为例说明：</p><p>导入包和类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> sklearn.cluster <span class="keyword">as</span> skc  <span class="comment"># 密度聚类</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics   <span class="comment"># 评估模型</span></span><br></pre></td></tr></table></figure><p>预处理数据</p><p>对良性样本训练</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">label1_df = df[df[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(label1_df.shape)</span><br><span class="line"></span><br><span class="line">label1_data = label1_df.drop([<span class="string">&#x27;subjectName&#x27;</span>,<span class="string">&#x27;label&#x27;</span>,<span class="string">&#x27;肿瘤类型&#x27;</span>,<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;QC&#x27;</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>主要函数</p><p>重要参数：eps：轮廓半径  min_samples：最小样本量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置半径为2880，最小样本量为19，遍历得轮廓系数最高 0.8164716886625932</span></span><br><span class="line">db = skc.DBSCAN(eps=<span class="number">1500</span>, min_samples = <span class="number">15</span>).fit(label1_data) <span class="comment">#DBSCAN聚类方法 还有参数，matric = &quot;&quot;距离计算方法</span></span><br><span class="line">label1_df[<span class="string">&#x27;labels&#x27;</span>] = db.labels_</span><br><span class="line">labels = db.labels_  <span class="comment">#和X同一个维度，labels对应索引序号的值 为她所在簇的序号，也就是聚类之后的结果。若簇编号为-1，表示为噪声</span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> sklearn.cluster <span class="keyword">as</span> skc  <span class="comment"># 密度聚类</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics   <span class="comment"># 评估模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对良性样本训练</span></span><br><span class="line">label1_df = df[df[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(label1_df.shape)</span><br><span class="line"></span><br><span class="line">label1_data = label1_df.drop([<span class="string">&#x27;subjectName&#x27;</span>,<span class="string">&#x27;label&#x27;</span>,<span class="string">&#x27;肿瘤类型&#x27;</span>,<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;QC&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#设置半径为2880，最小样本量为19，遍历得轮廓系数最高 0.8164716886625932</span></span><br><span class="line">db = skc.DBSCAN(eps=<span class="number">1500</span>, min_samples = <span class="number">15</span>).fit(label1_data) <span class="comment">#DBSCAN聚类方法 还有参数，matric = &quot;&quot;距离计算方法</span></span><br><span class="line">label1_df[<span class="string">&#x27;labels&#x27;</span>] = db.labels_</span><br><span class="line">labels = db.labels_  <span class="comment">#和X同一个维度，labels对应索引序号的值 为她所在簇的序号，也就是聚类之后的结果。若簇编号为-1，表示为噪声</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;每个样本的簇标号:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(labels)</span><br><span class="line">raito = <span class="built_in">len</span>(labels[labels[:] == -<span class="number">1</span>]) / <span class="built_in">len</span>(labels)  <span class="comment">#计算噪声点个数占总数的比例</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;噪声比:&#x27;</span>, <span class="built_in">format</span>(raito, <span class="string">&#x27;.2%&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">n_clusters_ = <span class="built_in">len</span>(<span class="built_in">set</span>(labels)) - (<span class="number">1</span> <span class="keyword">if</span> -<span class="number">1</span> <span class="keyword">in</span> labels <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 获取分簇的数目</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分簇的数目: %d&#x27;</span> % n_clusters_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;轮廓系数: %0.3f&quot;</span> % metrics.silhouette_score(label1_data, labels)) <span class="comment">#轮廓系数评价聚类的好坏</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;噪声的所有样本:&#x27;</span>)</span><br><span class="line">new_cluster = label1_data[labels == -<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(new_cluster.shape)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> manifold, datasets</span><br><span class="line">new_cluster_1 = label1_data[labels == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># t-SNE的降维与可视化</span></span><br><span class="line">ts = manifold.TSNE(n_components=<span class="number">2</span>, init=<span class="string">&#x27;pca&#x27;</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">y = ts.fit_transform(new_cluster_1)</span><br><span class="line">x = ts.fit_transform(new_cluster)</span><br><span class="line">plt.scatter(y[:, <span class="number">0</span>], y[:, <span class="number">1</span>], cmap=plt.cm.Spectral)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], cmap=plt.cm.Spectral)</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>遍历得轮廓系数最高的参数选择后结果</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.003.png" alt="BZ2IMAYAGA"></p><p>聚类结果</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.004.png" alt="E52IMAYAVY"></p><p>实验测试结果如下：</p><table><thead><tr><th align="left"><strong>逻辑回归</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.50</td><td align="left">0.875</td><td align="left">0.403</td></tr><tr><td align="left">DBSCAN</td><td align="left">0.604</td><td align="left">0.681</td><td align="left">0.546</td></tr></tbody></table><table><thead><tr><th align="left"><strong>支持向量机</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.409</td><td align="left">0.917</td><td align="left">0.275</td></tr><tr><td align="left">DBSCAN</td><td align="left">0.644</td><td align="left">0.611</td><td align="left">0.615</td></tr></tbody></table><table><thead><tr><th align="left"><strong>LightGBM</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.8</td><td align="left">0.389</td><td align="left">0.908</td></tr><tr><td align="left">DBSCAN</td><td align="left">0.814</td><td align="left">0.306</td><td align="left">0.901</td></tr></tbody></table><table><thead><tr><th align="left"><strong>XGBoost</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.794</td><td align="left">0.403</td><td align="left">0.897</td></tr><tr><td align="left">DBSCAN</td><td align="left">0.811</td><td align="left">0.292</td><td align="left">0.901</td></tr></tbody></table><table><thead><tr><th align="left"><strong>神经网络</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.339</td><td align="left">0.916</td><td align="left">0.187</td></tr><tr><td align="left">DBSCAN</td><td align="left">0.517</td><td align="left">0.736</td><td align="left">0.429</td></tr><tr><td align="left">根据对比发现，DBSCAN使各个模型的准确度都有一定程度的提升，但对灵敏度和特异性的影响有好有坏。</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="置信学习"><a href="#置信学习" class="headerlink" title="置信学习"></a><strong>置信学习</strong></h3><h4 id="思路及原理-1"><a href="#思路及原理-1" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>对噪声数据进行自动过滤，我们尝试采用置信学习（CL）的方法，CL 基于噪声数据剪枝的原理以计数的方式对噪声进行评估，并对数据集进行排序以进行置信训练。</p><p>在 Angluin 和Laird 分类噪声的假设基础上，将 CL 泛化到直接估计噪声标签和无损标签之间的联合分布。</p><p>实现置信学习，首先估计噪声标签和真实标签的联合分布，然后找出并过滤掉错误样本，最后过滤错误样本后，重新训练。</p><p>为获取上述的联合分布，需要使用cheanlab包下的find_label_issues函数，对“每个样本实际属于哪个类别”，“模型预测每个样本在每个类别的概率“，”选择是否是噪声数据的策略”这三个参数设置</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.005.png" alt="53TY2AYA4I"></p><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><p>导入置信学习的cheanlab</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cleanlab.classification <span class="keyword">import</span> CleanLearning</span><br><span class="line"><span class="keyword">from</span> cleanlab.<span class="built_in">filter</span> <span class="keyword">import</span> find_label_issues</span><br></pre></td></tr></table></figure><p>所用到的方法及变量解释</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ordered_label_issues = find_label_issues(</span><br><span class="line">    labels=train_label, <span class="comment"># 每个样本实际属于哪个类别</span></span><br><span class="line">    pred_probs = grid_model.predict_proba(train_data),  <span class="comment"># 模型预测每个样本在每个类别的概率</span></span><br><span class="line">    return_indices_ranked_by=<span class="string">&#x27;self_confidence&#x27;</span>, <span class="comment">#选择是否是噪声数据的策略</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ordered_label_issues.shape)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cgi <span class="keyword">import</span> print_arguments</span><br><span class="line"><span class="keyword">from</span> cleanlab.classification <span class="keyword">import</span> CleanLearning</span><br><span class="line"><span class="keyword">from</span> cleanlab.<span class="built_in">filter</span> <span class="keyword">import</span> find_label_issues</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">ordered_label_issues = find_label_issues(</span><br><span class="line">    labels=train_label, <span class="comment"># 每个样本实际属于哪个类别</span></span><br><span class="line">    pred_probs = grid_model.predict_proba(train_data),  <span class="comment"># 模型预测每个样本在每个类别的概率</span></span><br><span class="line">    return_indices_ranked_by=<span class="string">&#x27;self_confidence&#x27;</span>, <span class="comment">#选择是否是噪声数据的策略</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ordered_label_issues.shape)</span><br><span class="line"><span class="comment"># 将良性和恶性的分开</span></span><br><span class="line">noise_data11 = noise_data1[noise_data1[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line">noise_data10 = noise_data1[noise_data1[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line">cleaned_data11 = cleaned_data1[cleaned_data1[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line">cleaned_data10 = cleaned_data1[cleaned_data1[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line">cleaned_data11.to_csv(<span class="string">&#x27;./可视化/cleaned_data11.csv&#x27;</span>,index = <span class="literal">False</span>)</span><br><span class="line">cleaned_data10.to_csv(<span class="string">&#x27;./可视化/cleaned_data10.csv&#x27;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a><strong>结果</strong></h4><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.006.png" alt="V3UY2AYAOA"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.007.png" alt="ZTUY2AYBW4"></p><p>总结：以上结果表明比未优化稍微好一点，但相差不大。</p><h3 id="孤立森林"><a href="#孤立森林" class="headerlink" title="孤立森林"></a><strong>孤立森林</strong></h3><h4 id="思路及原理-2"><a href="#思路及原理-2" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>孤立森林根据离群点与正常值较为疏离，容易被孤立的特点，通过建立决策树，将离群点分离出来（异常样本更容易快速落入叶子结点，距离根节点更近）。</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.008.png" alt="HHGH6AYAKQ"></p><p>再利用集成学习bagging的思想，建立多颗决策树，在多棵树上都会被较先分离出来的就是离群点，用异常得分作为判断依据（sklearn中label是1为正常值，-1为异常值）</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.009.png" alt="IXGH6AYAJY"></p><p>实现思路：</p><p>先把两个训练集和一个测试集数据合在一起，通过label标签将良恶性分开，再各自通过离群点检测算法，将离群点筛选出来，完成后放入各模型中测试，并与不做处理的结果进行对比</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.010.png" alt="53GH6AYAHE"></p><h4 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><p>使用sklearn中的孤立森林模型</p><p>先导入sklearn中的孤立森林包</p><p>from sklearn.ensemble import IsolationForest</p><p>所用到的方法</p><p>sklearn.ensemble.IsolationForest( n_estimators&#x3D;100,  max_samples&#x3D;’auto’,  contamination&#x3D;’auto’,  max_features&#x3D;1.0, bootstrap&#x3D;False,  n_jobs&#x3D;None,  random_state&#x3D;None,  verbose&#x3D;0,  warm_start&#x3D;False )</p><p>参数解释如下：</p><p>n_estimators : iTree的个数，指定该森林中生成的随机树数量，默认为100个max_samples : 构建子树的样本数。如果设置的是”auto”，则max_samples&#x3D;min(256, n_samples)，n_samples即总样本的数量</p><p>contamination :取值范围为(0., 0.5),表示异常数据占给定的数据集的比例</p><p>max_features : 构建每个子树的特征数字</p><p>bootstrap :采样是有放回还是无放回</p><p>random_state :每次训练的随机性</p><p>具体实现代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> IsolationForest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将良性和恶性的分开</span></span><br><span class="line">label1_df = df[df[<span class="string">&#x27;label&#x27;</span>] == <span class="number">1</span>]</span><br><span class="line">label0_df = df[df[<span class="string">&#x27;label&#x27;</span>] == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 进行训练</span></span><br><span class="line">iforest = IsolationForest(n_estimators=<span class="number">100</span>, max_samples=<span class="string">&#x27;auto&#x27;</span>,  </span><br><span class="line">                          contamination=<span class="string">&#x27;auto&#x27;</span>, max_features=<span class="number">10</span>,  </span><br><span class="line">                          bootstrap=<span class="literal">False</span>, n_jobs=-<span class="number">1</span>, random_state=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 对恶性的进行孤立森林</span></span><br><span class="line">train_data = label1_df.drop([<span class="string">&#x27;subjectName&#x27;</span>,<span class="string">&#x27;label&#x27;</span>,<span class="string">&#x27;肿瘤类型&#x27;</span>,<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;QC&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">label1_df[<span class="string">&#x27;anomaly_label&#x27;</span>] = iforest.fit_predict(train_data) </span><br><span class="line">label1_df[<span class="string">&#x27;scores&#x27;</span>] = iforest.decision_function(train_data)</span><br><span class="line"><span class="built_in">print</span>(label1_df[label1_df.anomaly_label == -<span class="number">1</span>].shape)</span><br><span class="line"><span class="comment"># 对良性的进行孤立森林</span></span><br><span class="line">train_data = label0_df.drop([<span class="string">&#x27;subjectName&#x27;</span>,<span class="string">&#x27;label&#x27;</span>,<span class="string">&#x27;肿瘤类型&#x27;</span>,<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;QC&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">label0_df[<span class="string">&#x27;anomaly_label&#x27;</span>] = iforest.fit_predict(train_data) </span><br><span class="line">label0_df[<span class="string">&#x27;scores&#x27;</span>] = iforest.decision_function(train_data)</span><br><span class="line"><span class="built_in">print</span>(label0_df[label0_df.anomaly_label == -<span class="number">1</span>].shape)</span><br><span class="line"><span class="comment"># 再将恶性和良性的结果拼在一起</span></span><br><span class="line">df = pd.concat([label1_df,label0_df], axis = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 删除异常值</span></span><br><span class="line">df = df[df.anomaly_label == <span class="number">1</span>]</span><br><span class="line">df = df.drop([<span class="string">&#x27;anomaly_label&#x27;</span>,<span class="string">&#x27;scores&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df.shape)</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>对异常类型和非异常类型做直方图分布可视化如下</p><p>训练集v1（688），v2（73）+测试集（80），共841个样本</p><p>经过独立森林筛选后，从训练集中筛掉67个样本，从测试集中删掉7个，一共74个（良性22个，恶性52个），剩余样本767个</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.011.png" alt="NDGX6AYA3M"></p><p>实验测试结果如下：</p><table><thead><tr><th align="left"><strong>逻辑回归</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.625</td><td align="left">0.3</td><td align="left">0.95</td></tr><tr><td align="left">孤立森林</td><td align="left">0.712</td><td align="left">0.675</td><td align="left">0.625</td></tr></tbody></table><table><thead><tr><th align="left"><strong>支持向量机</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.7625</td><td align="left">0.775</td><td align="left">0.75</td></tr><tr><td align="left">孤立森林</td><td align="left">0.767</td><td align="left">0.675</td><td align="left">0.725</td></tr></tbody></table><table><thead><tr><th align="left"><strong>LightGBM</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.7125</td><td align="left">0.5</td><td align="left">0.925</td></tr><tr><td align="left">孤立森林</td><td align="left">0.67</td><td align="left">0.425</td><td align="left">0.825</td></tr></tbody></table><table><thead><tr><th align="left"><strong>XGBoost</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.7</td><td align="left">0.5</td><td align="left">0.9</td></tr><tr><td align="left">孤立森林</td><td align="left">0.725</td><td align="left">0.5</td><td align="left">0.825</td></tr></tbody></table><table><thead><tr><th align="left"><strong>神经网络</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">未做筛选</td><td align="left">0.6375</td><td align="left">0.3</td><td align="left">0.875</td></tr><tr><td align="left">孤立森林</td><td align="left">0.575</td><td align="left">0.15</td><td align="left">0.9</td></tr></tbody></table><h4 id="结果可视化"><a href="#结果可视化" class="headerlink" title="结果可视化"></a><strong>结果可视化</strong></h4><h5 id="使用matplotlib做可视化"><a href="#使用matplotlib做可视化" class="headerlink" title="使用matplotlib做可视化"></a><strong>使用matplotlib做可视化</strong></h5><p>利用matplotlib对年龄，肿瘤大小，乳房大小，肿瘤类型中的全部值，正常值和异常值分别做良恶性人数可视化。其中年龄和肿瘤大小为数值型数据，使用直方图进行可视化；乳房大小和肿瘤类型为文本型数据，使用条形图做可视化，可视化结果如下</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.012.png" alt="TP4I2AYA34"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.013.png" alt="T74I2AYBDA"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.014.png" alt="UH4I2AYAWQ"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.015.png" alt="V34I2AYAOY"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.016.png" alt="WL4I2AYA34"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.017.png" alt="WX4I2AYAOA"></p><h5 id="使用Excel做可视化"><a href="#使用Excel做可视化" class="headerlink" title="使用Excel做可视化"></a><strong>使用Excel做可视化</strong></h5><p>使用Excel对全部数据，正常值，和异常值的良恶性样本所占比例进行可视化分析，观察在年龄，肿瘤大小，乳房大小上数据的分布特征，对后续优化提供建议。</p><p>如在肿瘤大小中，观察到小于0.6的样本中基本为良性，则在后续模型训练时，可对这一范围内的样本加大良性判定权重。</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.018.png" alt="IX4Y2AYAS4"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.019.png" alt="JH4Y2AYABM"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.020.png" alt="JT4Y2AYAU4"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.021.png" alt="OD4Y2AYAPA"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.022.png" alt="OP4Y2AYA34"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.023.png" alt="O34Y2AYAHA"></p><h2 id="特征筛选"><a href="#特征筛选" class="headerlink" title="特征筛选"></a><strong>特征筛选</strong></h2><h3 id="正负样本"><a href="#正负样本" class="headerlink" title="正负样本"></a><strong>正负样本</strong></h3><h4 id="思路及原理-3"><a href="#思路及原理-3" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>原测试数据集中包含189个正样本（label&#x3D;1）502个负样本，其中测试数据集由train_data_v1.csv组成，正样本数量过低可能使测试中的准确度，灵敏度及特异性降低，故采用过采样与欠采样结合的方式均衡正负样本比例。</p><p><strong>过采样：</strong>重复正比例数据，实际上没有为模型引入更多数据，过分强调正比例数据，会放大正比例噪音对模型的影响。</p><p><strong>欠采样</strong>：丢弃大量数据，和过采样一样会存在过拟合的问题。</p><p>为防止单一使用过采样或欠采样导致样本类型过拟合，计划过采样正样本的两倍，并选择同等数量的负样本使其均衡。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h4><p>过采样三倍正样本</p><p>positive_data &#x3D; train_df[train_df[‘label’]&#x3D;&#x3D;1]<br>positive_data_2 &#x3D; positive_data.append(positive_data)</p><p>欠采样与正样本相同数量的负样本</p><p>negative_data &#x3D; train_df[train_df[‘label’]&#x3D;&#x3D;0].sample(n&#x3D;372,random_state&#x3D;1)<br>train_df_better &#x3D; negative_data.append(positive_data_2)</p><p>最终正负样本数：372+372&#x3D;744个</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.024.png" alt="GRGIKAYAYU"></p><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>比较准确度，灵敏度及特异性改变情况</p><p>未使用正负样本均衡</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.025.png" alt="HFYIMAYAWA"></p><p>优化后结果</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.026.png" alt="KVYIMAYAJY"></p><p>优化结果分析</p><p>对逻辑回归、树模型和神经网络有一定的优化效果，但对支持向量机模型效果较少，对灵敏度特异性的优化程度较低，波动较大，且可能存在数据本身存在异常的影响。</p><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a><strong>PCA</strong></h3><h4 id="思路及原理-4"><a href="#思路及原理-4" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>所给的数据集（data_v1_allFeatures.csv）中有290个特征，我们尝试在特征筛选阶段，使用PCA降维的方式对数据做降维处理，以加快模型训练速度，尝试提高模型的准确度，灵敏度及特异性。</p><p>PCA即主成分分析，其通过投影的方式将高维的数据映射到低维的空间中，并保证在所投影的维度上，原数据的信息量最大，从而使用较少的数据维度，保留住较多的原始数据特性。</p><p>如下图例子所示，通过变换坐标轴的方式，消除了三个样本点的x2轴（即x2特征），将二维数据降为一维，同时保证了三个样本点的区分度</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.027.png" alt="BTEH6AYB3M"></p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.028.png" alt="DHEH6AYD3M"></p><h4 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><p>使用sklearn中的PCA模型</p><p>先导入sklearn中的PCA包</p><p>from sklearn.decomposition import PCA</p><p>其函数所需参数为</p><p>sklearn.decomposition.PCA(n_components&#x3D;None, copy&#x3D;True, whiten&#x3D;False)</p><p>n_components: PCA算法中所要保留的主成分个数n，也即保留下来的特征个数n</p><p>copy:表示是否在运行算法时，将原始训练数据复制一份</p><p>whiten：白化，使得每个特征具有相同的方差</p><p>使用到的方法有</p><p>fit(X,y&#x3D;None)  # 表示用数据X来训练PCA模型。因为PCA是无监督学习算法，此处y自然等于None。<br>fit_transform(X) # 用X来训练PCA模型，同时返回降维后的数据￥<br>inverse_transform() # 将降维后的数据转换成原始数据<br>transform(X) # 将数据X转换成降维后的数据。当模型训练好后，对于新输入的数据，都可以用transform方法来降维。</p><p>实现代码如下：</p><p>读入数据集后，先取出label，mark两列保存下来，再将数据集中用不到的5列删除</p><p>取主成分个数为80进行模型训练，将训练结果与先前存下来的label，mark两列保存到文件（selectFeatureDataTopPCA.csv）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">df5 = pd.read_csv(<span class="string">&#x27;./data/data_v1_allFeatures.csv&#x27;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df5_label = df5[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">df5_mark = df5[<span class="string">&#x27;mark&#x27;</span>]</span><br><span class="line">data5 = df5.drop([<span class="string">&#x27;subjectName&#x27;</span>,<span class="string">&#x27;label&#x27;</span>,<span class="string">&#x27;肿瘤类型&#x27;</span>,<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;QC&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(data5.shape)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pca_line = PCA().fit(data5)</span></span><br><span class="line"><span class="string">pca_line.explained_variance_ratio_</span></span><br><span class="line"><span class="string">plt.figure(figsize=[200,5])</span></span><br><span class="line"><span class="string">plt.xticks(np.linspace(0,290,290,endpoint=True))</span></span><br><span class="line"><span class="string">plt.plot(np.cumsum(pca_line.explained_variance_ratio_))</span></span><br><span class="line"><span class="string">plt.xlabel(&quot;number of components after dimension reduction&quot;)</span></span><br><span class="line"><span class="string">plt.ylabel(&quot;cumulative explained variance ratio&quot;)</span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">newdf = PCA(n_components=<span class="number">80</span>).fit_transform(data5)</span><br><span class="line">newdf = pd.DataFrame(newdf)</span><br><span class="line">newdf[<span class="string">&#x27;label&#x27;</span>] = df5_label</span><br><span class="line">newdf[<span class="string">&#x27;mark&#x27;</span>] = df5_mark</span><br><span class="line"><span class="built_in">print</span>(newdf.shape)</span><br><span class="line">newdf.to_csv(<span class="string">&#x27;./selectFeatureDataTopPCA.csv&#x27;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>在PCA中，信息用方差来表示</p><p>explained_variance：降维后的方差</p><p>通过绘制图像来观察，在不同保留维度下，降维后所有成分的方差和</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.029.png" alt="4HEX6AYASM"></p><p>以下为n不同取值时训练模型所得出的结果</p><table><thead><tr><th align="left"><strong>逻辑回归</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">树模型</td><td align="left">0.7375</td><td align="left">0.775</td><td align="left">0.7</td></tr><tr><td align="left">PCA（3）</td><td align="left">0.58</td><td align="left">0.175</td><td align="left">1.0</td></tr><tr><td align="left">PCA（50）</td><td align="left">0.675</td><td align="left">0.5</td><td align="left">0.85</td></tr><tr><td align="left">PCA（80）</td><td align="left">0.75</td><td align="left">0.625</td><td align="left">0.875</td></tr><tr><td align="left">PCA（100）</td><td align="left">0.675</td><td align="left">0.575</td><td align="left">0.775</td></tr></tbody></table><table><thead><tr><th align="left"><strong>支持向量机</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">树模型</td><td align="left">0.6625</td><td align="left">0.7</td><td align="left">0.625</td></tr><tr><td align="left">PCA（3）</td><td align="left">0.575</td><td align="left">0.175</td><td align="left">0.975</td></tr><tr><td align="left">PCA（50）</td><td align="left">0.55</td><td align="left">0.175</td><td align="left">0.925</td></tr><tr><td align="left">PCA（80）</td><td align="left">0.55</td><td align="left">0.175</td><td align="left">0.925</td></tr></tbody></table><table><thead><tr><th align="left"><strong>LightGBM</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">树模型</td><td align="left">0.625</td><td align="left">0.325</td><td align="left">0.925</td></tr><tr><td align="left">PCA（3）</td><td align="left">0.5625</td><td align="left">0.175</td><td align="left">0.95</td></tr><tr><td align="left">PCA（50）</td><td align="left">0.5625</td><td align="left">0.175</td><td align="left">0.95</td></tr><tr><td align="left">PCA（80）</td><td align="left">0.5625</td><td align="left">0.175</td><td align="left">0.95</td></tr></tbody></table><table><thead><tr><th align="left"><strong>XGBoost</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">树模型</td><td align="left">0.6</td><td align="left">0.3</td><td align="left">0.9</td></tr><tr><td align="left">PCA（3）</td><td align="left">0.6</td><td align="left">0.3</td><td align="left">0.9</td></tr><tr><td align="left">PCA（50）</td><td align="left">0.6</td><td align="left">0.3</td><td align="left">0.9</td></tr><tr><td align="left">PCA（80）</td><td align="left">0.6</td><td align="left">0.3</td><td align="left">0.9</td></tr></tbody></table><table><thead><tr><th align="left"><strong>神经网络</strong></th><th align="left"><strong>准确性</strong></th><th align="left"><strong>灵敏度</strong></th><th align="left"><strong>特异性</strong></th></tr></thead><tbody><tr><td align="left">树模型</td><td align="left">0.5125</td><td align="left">0.075</td><td align="left">0.95</td></tr><tr><td align="left">PCA（3）</td><td align="left">0.5625</td><td align="left">0.225</td><td align="left">0.9</td></tr><tr><td align="left">PCA（50）</td><td align="left">0.6875</td><td align="left">0.4</td><td align="left">0.975</td></tr><tr><td align="left">PCA（80）</td><td align="left">0.6</td><td align="left">0.4</td><td align="left">0.8</td></tr><tr><td align="left">总结：PCA降维方法在该样本集中的效果并不明显</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="方差过滤"><a href="#方差过滤" class="headerlink" title="方差过滤"></a><strong>方差过滤</strong></h3><h4 id="思路及原理-5"><a href="#思路及原理-5" class="headerlink" title="思路及原理"></a><strong>思路及原理</strong></h4><p>如果样本在这个特征上基本没有差异，从数学角度上看，就代表一个特征本身的方差很小。这就为我们所做的工作提供了一个思路————方差过滤</p><p>实现方差过滤，利用sklearn中的方差过滤模型。这是通过特征本身的方差来筛选特征的类。该类有着重要参数threshold，表示方差的阈值，舍弃所有方差小于threshold的特征，如果不填，则阈值默认设置为0，即删除所有的记录都相同的特征。但是初始295个经过阈值默认为0下的筛选依然剩下了290个特征，因此可以看出阈值的选择是值得需要探讨的地方。</p><p>最终，在阈值选择方面打算留下一半的特征，即设定一个让特征总数减半的方差阈值，只要找到特征方差的中位数，再将这个中位数作为参数threshold的值输入。</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.030.png" alt="DPWI2AYADA"></p><h4 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><p>导入sklearn中<strong>VarianceThreshold</strong></p><p>from sklearn.feature_selection import VarianceThreshold</p><p>其函数所需参数为：</p><p>VarianceThreshold(threshold) #参数threshold，表示方差的阈值</p><p>方差阈值的设置：</p><p>np.median(train_data.var().values)#筛选一半的特征，采用中位数做阈值</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold  <span class="comment"># 方差过滤</span></span><br><span class="line"><span class="comment">#selector = VarianceThreshold()</span></span><br><span class="line">selector = VarianceThreshold(np.median(train_data.var().values))<span class="comment">#筛选一半的特征，采用中位数做阈值</span></span><br><span class="line">x_train1 = selector.fit_transform(train_data)  <span class="comment"># 方差过滤</span></span><br><span class="line">x_test1 = selector.transform(test_data)  </span><br><span class="line"><span class="built_in">print</span>(x_train1.shape)</span><br><span class="line"><span class="built_in">print</span>(x_test1.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留特征名称</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">all_name = train_data.columns.values.tolist()  <span class="comment"># 获得所有的特征名称</span></span><br><span class="line">select_name_index0 = selector.get_support(indices=<span class="literal">True</span>)  <span class="comment"># 留下特征的索引值，list格式</span></span><br><span class="line">select_name0 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> select_name_index0:</span><br><span class="line">    select_name0.append(all_name[i])</span><br><span class="line"><span class="built_in">print</span>(select_name0)</span><br><span class="line">select_name0=pd.to_numeric(select_name0,errors=<span class="string">&#x27;coerce&#x27;</span>)</span><br><span class="line">select_name0 = pd.DataFrame(select_name0)</span><br><span class="line"><span class="built_in">print</span>(select_name0.dtypes)</span><br><span class="line"><span class="comment">#x_test1=pd.DataFrame(x_test1)</span></span><br><span class="line"><span class="comment">#x_test1=pd.concat([x_test1,select_name0],axis=0)</span></span><br><span class="line">df5 = np.vstack((x_test1,x_train1))</span><br><span class="line">df5 = pd.DataFrame(df5)</span><br><span class="line">df5[<span class="string">&#x27;label&#x27;</span>]=df_label</span><br><span class="line">df5[<span class="string">&#x27;mark&#x27;</span>]=df_mark</span><br><span class="line"><span class="built_in">print</span>(df5.shape)</span><br><span class="line">df5.to_csv(<span class="string">&#x27;./test.csv&#x27;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>选择筛取一半的特征训练模型所得出的结果</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.031.png" alt="BHXY2AYAIY"></p><p>总结：不断调整阈值，观察阈值改变在此模型的表现，结果表现时好时坏，以左图阈值选择为一半为例，方差筛选可能会导致部分有效特征被筛选掉。因此如何去更好的利用这一算法，我们认为，可以在特征筛选上，先使用方差筛选，阈值设置为较小的值或者0，优先筛选掉明显用不上的特征，接着继续选择更优的特征选择方法，继续削减特征数量。</p><h3 id="树模型筛选"><a href="#树模型筛选" class="headerlink" title="树模型筛选"></a><strong>树模型筛选</strong></h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h4><p>使用三种树模型，XGBoost，Extra-Tree和RandomForest来评估数据集中特征的重要性，分别求出三种模型中，各自认为重要性最高的100个特征值，然后再求交集，选出三种模型均认为较为重要的特征</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a><strong>具体实现</strong></h4><p>调用sklearn中的feature_importance对特征的重要性进行评估，一般来说，重要性提供了一个评分，它表明每个特性在模型中增强决策树的构建中有多有用或多有价值。属性用于使用决策树做出关键决策的次数越多，其相对重要性就越高。</p><p>传入XGBoost模型所得结果如下</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.032.png" alt="QCY4SAYAFE"></p><p>传入Extra-Tree模型所得结果如下</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.033.png" alt="UOY4SAYAEU"></p><p>传入RandomForest模型所得结果如下</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.034.png" alt="YCY4SAYA2Y"></p><h4 id="结果-6"><a href="#结果-6" class="headerlink" title="结果"></a><strong>结果</strong></h4><p>对三种模型所求出的前一百个重要特征求交集，最终选出95个重要特征，完成筛选</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将不同筛选模型得到的前100个特征求交集</span></span><br><span class="line">feat_imp_xgb = feat_imp_xgb_100.index.values</span><br><span class="line">feat_imp_rfc = feat_imp_rfc_100.index.values</span><br><span class="line">feat_imp_Extra = feat_imp_Extra_100.index.values</span><br><span class="line"></span><br><span class="line">feat_imp_all = <span class="built_in">list</span>(feat_imp_xgb) + <span class="built_in">list</span>(feat_imp_rfc) + <span class="built_in">list</span>(feat_imp_Extra)</span><br><span class="line"><span class="comment"># 通过字典统计每个元素出现个数</span></span><br><span class="line">feat_dic = &#123;&#125;</span><br><span class="line">keys = []</span><br><span class="line"><span class="keyword">for</span> feat <span class="keyword">in</span> feat_imp_all:</span><br><span class="line">    <span class="keyword">if</span> feat <span class="keyword">not</span> <span class="keyword">in</span> feat_dic.keys():</span><br><span class="line">        feat_dic[feat] = feat_imp_all.count(feat) <span class="comment"># 如果列表里面的元素不在字典key值中，那么创建一个新的key并统计元素出现的次数</span></span><br><span class="line"><span class="comment"># 如果出现的次数大于等于2，则说明该特征比较重要</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> feat_dic.items():</span><br><span class="line">    <span class="keyword">if</span> value &gt;= <span class="number">2</span>:</span><br><span class="line">        keys.append(key)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(keys))</span><br></pre></td></tr></table></figure><h2 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a><strong>参数调整</strong></h2><p>使用网格搜索的方式进行参数调整。</p><h3 id="逻辑回归-交叉验证"><a href="#逻辑回归-交叉验证" class="headerlink" title="逻辑回归+交叉验证"></a><strong>逻辑回归+交叉验证</strong></h3><h4 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a><strong>参数含义</strong></h4><ul><li>cv：交叉验证折数，默认None代表3</li><li>penalty：采用何种正则化，默认”l2”，可选”l1”，但注意使用”newton-cg”、”sag”和”lbfgs”这三种优化算法时仅支持”l2”。</li><li>scoring：评分函数，默认使用”accuracy”准确度，详见<a href="https://ster.im/py_sklearn_2/">《SKlearn模型评估》</a>。</li><li>solver：优化算法，可选”newton-cg”、”lbfgs”（默认）、”liblinear”、”sag”、”saga”。对于小数据集可选”liblinear”，巨型数据集选择随机梯度下降”sag”或”saga”更快；此外，进行多分类任务尽量不选择”liblinear”，因为其只能采用一对多的分类方式。</li><li>max_iter：优化算法的最大迭代次数。</li><li>class_weight：类别权重，默认视所有类别具有相同的权重，可选”balanced”自动按照类别频率分配权重，也可指定一个字典。</li><li>multi_class：多分类时的分类策略，可选”ovr”（默认）、”multinomial”、”auto”。”ovr”即一对多，迭代快、准确性不如多对多；”multinomial”为多对多，迭代慢、准确度高。当优化算法使用”liblinear”时无法使用”multinomial”。</li><li>random_state：随机数种子。</li></ul><h4 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a><strong>网格搜索</strong></h4><ul><li>scoring&#x3D;None：模型评价标准，默认None。</li><li><code> </code>n_jobs&#x3D;1 进程个数，默认为1。 若值为 -1，则用所有的CPU进行运算。 若值为1，则不进行并行运算，这样的话方便调试。</li><li>refit&#x3D;True：默认为True,程序将会以交叉验证训练集得到的最佳参数，重新对所有可用的训练集与开发集进行，作为最终用于性能评估的最佳模型参数。即在搜索参数结束后，用最佳参数结果再次fit一遍全部数据集。</li><li><code> </code>cv&#x3D;None：交叉验证参数，默认None，使用三折交叉验证。</li><li>pre_dispatch&#x3D;‘2*n_jobs’：指定总共分发的并行任务数。当n_jobs大于1时，数据将在每个运行点进行复制，这可能导致OOM，而设置pre_dispatch参数，则可以预先划分总共的job数量，使数据最多被复制pre_dispatch次</li></ul><h4 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a><strong>优化细节</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression()</span><br><span class="line">C = np.logspace(-<span class="number">1</span>, <span class="number">5</span>, <span class="number">100</span>) <span class="comment">#增加c从40到100</span></span><br><span class="line">class_weight= [<span class="string">&quot;balanced&quot;</span>, <span class="literal">None</span>] </span><br><span class="line">solver = [<span class="string">&quot;lbfgs&quot;</span>, <span class="string">&quot;liblinear&quot;</span>, <span class="string">&quot;sag&quot;</span>, <span class="string">&quot;saga&quot;</span>,<span class="string">&quot;newton-cg&quot;</span>]<span class="comment"># 增加newton-cg&quot;优化算法选项</span></span><br><span class="line">multi_class = [<span class="string">&quot;multinomial&quot;</span>,<span class="string">&quot;ovr&quot;</span>,<span class="string">&quot;auto&quot;</span>] <span class="comment">#增加分类策略选择</span></span><br><span class="line"></span><br><span class="line">param_grid = [&#123;<span class="string">&quot;penalty&quot;</span> : [<span class="string">&quot;l2&quot;</span>],</span><br><span class="line">              <span class="string">&quot;C&quot;</span> : C,</span><br><span class="line">              <span class="string">&quot;multi_class&quot;</span> : multi_class ,</span><br><span class="line">              <span class="string">&quot;class_weight&quot;</span>: class_weight,</span><br><span class="line">              <span class="string">&quot;solver&quot;</span>: solver&#125;]</span><br><span class="line"></span><br><span class="line">grid_model = GridSearchCV(estimator=model,</span><br><span class="line">                          param_grid=param_grid,</span><br><span class="line">                          cv=<span class="number">7</span>,<span class="comment"># 调整至七折交叉验证</span></span><br><span class="line">                          scoring = <span class="string">&quot;f1&quot;</span>,</span><br><span class="line">                          refit=<span class="literal">True</span> , <span class="comment">#重新验证最佳参数</span></span><br><span class="line">                          pre_dispatch= <span class="number">10</span>, <span class="comment"># 减少搜索时间</span></span><br><span class="line">                          n_jobs = -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">grid_model.fit(train_data, train_label)</span><br></pre></td></tr></table></figure><h4 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a><strong>优化结果</strong></h4><table><thead><tr><th align="left"></th><th align="left">最优模型分数</th><th align="left">准确度</th><th align="left">灵敏度</th><th align="left">特异性</th></tr></thead><tbody><tr><td align="left">优化前</td><td align="left">0.494421</td><td align="left">0.625</td><td align="left">0.425</td><td align="left">0.825</td></tr><tr><td align="left">优化后</td><td align="left">0.513697</td><td align="left">0.7375</td><td align="left">0.725</td><td align="left">0.75</td></tr></tbody></table><h3 id="支持向量机模型"><a href="#支持向量机模型" class="headerlink" title="支持向量机模型"></a><strong>支持向量机模型</strong></h3><h4 id="参数含义-1"><a href="#参数含义-1" class="headerlink" title="参数含义"></a><strong>参数含义</strong></h4><ul><li>C：惩罚系数C，默认值为1.0。</li><li>kernel：核函数，默认使用”rbf”径向基函数，可选”linear”、”poly”、”sigmoid”、”precomputed”或者一个可调用的函数。</li><li>degree：多项式核函数的维度d，仅在核函数选择”poly”时有效。默认值为3。</li><li>gamma：”rbf”、”poly”、”sigmoid”的系数gamma，默认为”auto”，取特征数量的倒数，如果使用”scale”，则取特征数量乘以变量二阶矩再取倒数。</li><li>coef0：核函数中的独立项，仅在核函数选择”poly”、”sigmoid”时有效。默认值为0.0。</li><li>shrinking：是否使用shrinking heuristic方法，默认为True。</li><li>probability：是否使用概率估计，默认为False。</li><li>tol：停止训练的误差精度，默认值为1e-3。</li><li>cache_size：核函数缓存大小。</li><li>class_weight：接收字典或字典的列表来指定各类别的的权重，也可指定为”balanced”，使用类别出现频率的倒数作为权重。使用默认的None将视所有类别具有相同的权重。</li><li>max_iter：最大迭代次数，默认为-1即无限制。</li><li>decision_function_shape：多分类策略，可选”ovo”或”ovr”（默认）。</li><li>random_state：随机数种子。</li></ul><h4 id="优化细节-1"><a href="#优化细节-1" class="headerlink" title="优化细节"></a><strong>优化细节</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = [</span><br><span class="line">&#123;<span class="string">&#x27;kernel&#x27;</span>:[<span class="string">&#x27;linear&#x27;</span>],<span class="string">&#x27;C&#x27;</span>:[<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>]&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;kernel&#x27;</span>:[<span class="string">&#x27;sigmoid&#x27;</span>],<span class="string">&#x27;C&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>],<span class="string">&#x27;gamma&#x27;</span>:[<span class="number">1</span>,<span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">0.001</span>],<span class="string">&#x27;coef0&#x27;</span>:[<span class="number">0.01</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>],&#125;,<span class="comment">#增加双曲正切函数tanh核函数</span></span><br><span class="line">&#123;<span class="string">&#x27;kernel&#x27;</span>:[<span class="string">&#x27;poly&#x27;</span>],<span class="string">&#x27;C&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>],<span class="string">&#x27;degree&#x27;</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="string">&#x27;coef0&#x27;</span>:[<span class="number">0.01</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>],&#125;,<span class="comment">#增加coef0控制核函数中的独立项</span></span><br><span class="line">&#123;<span class="string">&#x27;kernel&#x27;</span>:[<span class="string">&#x27;rbf&#x27;</span>],<span class="string">&#x27;C&#x27;</span>:[<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>], <span class="string">&#x27;gamma&#x27;</span>:[<span class="number">1</span>,<span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">0.001</span>]&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;class_weight&#x27;</span>:[<span class="string">&#x27;balanced&#x27;</span>,<span class="literal">None</span>]&#125;]</span><br><span class="line"></span><br><span class="line">model = svm.SVC(probability=<span class="literal">True</span>,shrinking = <span class="literal">True</span>)<span class="comment">#进行启发式训练</span></span><br><span class="line"></span><br><span class="line">model = GridSearchCV(estimator=model, </span><br><span class="line">                     param_grid=params, </span><br><span class="line">                     cv=<span class="number">8</span>, <span class="comment">#调整至八折交叉验证</span></span><br><span class="line">                     scoring = <span class="string">&#x27;f1&#x27;</span>, </span><br><span class="line">                     refit=<span class="literal">True</span> , <span class="comment">#重新验证最佳参数</span></span><br><span class="line">                     pre_dispatch= <span class="number">10</span>, <span class="comment"># 减少搜索时间</span></span><br><span class="line">                     n_jobs = -<span class="number">1</span>)</span><br><span class="line">model.fit(train_data, train_label)</span><br></pre></td></tr></table></figure><h4 id="优化结果-1"><a href="#优化结果-1" class="headerlink" title="优化结果"></a><strong>优化结果</strong></h4><p>ps：时间消耗大幅度提升</p><table><thead><tr><th align="left"></th><th align="left">最优模型分数</th><th align="left">准确度</th><th align="left">灵敏度</th><th align="left">特异性</th></tr></thead><tbody><tr><td align="left">优化前</td><td align="left">0.511085</td><td align="left">0.725</td><td align="left">0.65</td><td align="left">0.8</td></tr><tr><td align="left">优化后</td><td align="left">0.524251</td><td align="left">0.725</td><td align="left">0.65</td><td align="left">0.8</td></tr></tbody></table><h3 id="树模型"><a href="#树模型" class="headerlink" title="树模型"></a><strong>树模型</strong></h3><h4 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a><strong>XGBoost</strong></h4><p>集成算法通过在数据上构建多个弱评估器，汇总所有弱评估器的建模结果，以获取比单个模型更好的回归或分类表现。弱评估器被定义为是表现至少比随机猜测更好的模型，即预测准确率不低于50%的任意模型</p><p>方法一采用sklearn中的API与其他机器学习模型一样进行fit和predict的流程来运行XGBoost</p><p>方法二采用xgboost原生接口，采用train和predict，方便调参</p><p><img src="/img/Aspose.Words.e44d2fdf-4ed4-4509-adad-57b9f558018a.035.png" alt="3PA4SAYA4Q"></p><p>max_depth：基学习器的深度，增加该值会使基学习器变得更加复杂，荣易过拟合，设为0表示不设限制，对于<strong>depth-wise</strong>的基学习器学习方法需要控制深度</p><p>min_child_weight：子节点所需的样本权重和(hessian)的最小阈值，若是基学习器切分后得到的叶节点中样本权重和低于该阈值则不会进一步切分，在线性模型中该值就对应每个节点的最小样本数，该值越大模型的学习约保守，同样用于防止模型过拟合</p><p>gamma：叶节点进一步切分的最小损失下降的阈值(超过该值才进一步切分)，越大则模型学习越保守，用来控制基学习器的复杂度</p><p>XGBoost</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">XGBoost</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score,f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./selectFeatureDataTopRfc100.csv&#x27;</span>)</span><br><span class="line">train_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;train&#x27;</span>]</span><br><span class="line">test_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_label = train_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">train_data=train_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">test_label = test_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">test_data=test_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分层k折交叉检验</span></span><br><span class="line">skf = StratifiedKFold(n_splits=<span class="number">5</span>)  </span><br><span class="line">result_xgb = []</span><br><span class="line">fold = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> train_idx, val_idx <span class="keyword">in</span> skf.split(train_data, train_label):</span><br><span class="line">    train_x = train_data.loc[train_idx]</span><br><span class="line">    train_y = train_label.loc[train_idx]</span><br><span class="line">    val_x = train_data.loc[val_idx]</span><br><span class="line">    val_y = train_label.loc[val_idx]</span><br><span class="line">    d_train = xgb.DMatrix(train_x, train_y)</span><br><span class="line">    d_val = xgb.DMatrix(val_x, val_y)</span><br><span class="line">    d_test = xgb.DMatrix(test_data)</span><br><span class="line"></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>:<span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;min_child_weight&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;num_class&#x27;</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;eta&#x27;</span>: <span class="number">0.1</span>,  <span class="comment">#学习率</span></span><br><span class="line">        <span class="string">&#x27;gamma&#x27;</span>: <span class="number">0.1</span>, <span class="comment">#后剪枝参数，取值在[0, 1]，越大越保守</span></span><br><span class="line">        <span class="string">&#x27;seed&#x27;</span>: <span class="number">1234</span>,</span><br><span class="line">        <span class="string">&#x27;alpha&#x27;</span>: <span class="number">1</span>,  <span class="comment">#L1正则项的惩罚系数</span></span><br><span class="line">        <span class="string">&#x27;eval_metric&#x27;</span>: <span class="string">&#x27;auc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    num_round = <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 方式一：采用sklearn接口，采用fit 和 predict</span></span><br><span class="line">    <span class="comment"># model_xgb = xgb.XGBClassifier()</span></span><br><span class="line">    <span class="comment"># model_xgb.fit(train_x, train_y, verbose=False) </span></span><br><span class="line">    <span class="comment"># pred_train = model_xgb.predict(train_x)</span></span><br><span class="line">    <span class="comment"># pred_val = model_xgb.predict(val_x)</span></span><br><span class="line">    <span class="comment"># pred_xgb = model_xgb.predict(X_test)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方式二：采用xgboost原生接口，采用train和predict，方便调参</span></span><br><span class="line">    model_xgb = xgb.train(params, d_train, num_round)</span><br><span class="line">    pred_train = model_xgb.predict(d_train)</span><br><span class="line">    pred_val = model_xgb.predict(d_val)</span><br><span class="line">    pred_xgb = model_xgb.predict(d_test)</span><br><span class="line"></span><br><span class="line">    auc_train = roc_auc_score(train_y, pred_train)</span><br><span class="line">    auc_val = roc_auc_score(val_y, pred_val)</span><br><span class="line">    f_score_train = f1_score(train_y, pred_train)</span><br><span class="line">    f_score_val = f1_score(val_y, pred_val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Fold: %d, AUC_train: %.4f, AUC_val: %.4f, F1-score_train: %.4f, F1-score_val: %.4f&#x27;</span>%(fold, </span><br><span class="line">        auc_train, auc_val, f_score_train, f_score_val))</span><br><span class="line"></span><br><span class="line">    result_xgb.append(pred_xgb)</span><br><span class="line"></span><br><span class="line">    fold += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result_xgb = pd.DataFrame(result_xgb).T</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;result_xgb.shape = &#x27;</span>, result_xgb.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将5次预测结果求平均值</span></span><br><span class="line">result_xgb[<span class="string">&#x27;average&#x27;</span>] = result_xgb.mean(axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终预测结果</span></span><br><span class="line">result_xgb[<span class="string">&#x27;xgb_predict&#x27;</span>] = result_xgb[<span class="string">&#x27;average&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="number">1</span> <span class="keyword">if</span> x&gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 特征重要性</span></span><br><span class="line">plt.figure(figsize=(<span class="number">40</span>, <span class="number">30</span>))</span><br><span class="line">plot_importance(model_xgb)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出结果</span></span><br><span class="line"><span class="comment"># result = pd.read_csv(&#x27;./data/testSubjectName.csv&#x27;)</span></span><br><span class="line"><span class="comment"># result[&#x27;xgb_predict&#x27;] = result_xgb[&#x27;xgb_predict&#x27;]</span></span><br><span class="line"><span class="comment"># result.to_csv(&#x27;./data/testSubjectName.csv&#x27;,index=False)</span></span><br></pre></td></tr></table></figure><h4 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a><strong>LightGBM</strong></h4><p>LightGBM（Light Gradient Boosting Machine）是一个实现GBDT算法的框架，支持高效率的并行训练，并且具有更快的训练速度、更低的内存消耗、更好的准确率、支持分布式可以快速处理海量数据等优点。</p><p>learning_rate: 学习率。默认设置为0.1，一般设置在0.05-0.1之间。选择比较小的学习率能获得稳定较好的模型性能。</p><p>max_depth: 树模型的最大深度。防止过拟合的最重要的参数，一般限制为3~5之间。是需要调整的核心参数，对模型性能和泛化能力有决定性作用。</p><p>num_leaves: 一棵树上的叶子节点个数。默认设置为31，和max_depth配合来空值树的形状，一般设置为(0, 2^max_depth - 1]的一个数值。是一个需要重点调节的参数，对模型性能影响很大。</p><p>min_child_sample: 一个叶子上的最小数据量。默认设置为20。根据数据量来确定，当数据量比较大时，应该提升这个数值，让叶子节点的数据分布相对稳定，提高模型的泛化能力。</p><p>Lightgbm</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Lightgbm</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> lightgbm</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./selectFeatureDataTopRfc100.csv&#x27;</span>)</span><br><span class="line">train_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;train&#x27;</span>]</span><br><span class="line">test_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_label = train_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">train_data=train_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">test_label = test_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">test_data=test_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_by_lgb</span>(<span class="params">train_data,train_label,test_data,random_state=<span class="number">2022</span>,n_splits=<span class="number">5</span>,metric=<span class="string">&#x27;auc&#x27;</span>,num_round=<span class="number">10000</span>,early_stopping_rounds=<span class="number">100</span></span>):</span><br><span class="line">    kfold = KFold(n_splits=n_splits, shuffle=<span class="literal">True</span>, random_state=random_state)</span><br><span class="line">    fold=<span class="number">0</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="keyword">for</span> train_idx, val_idx <span class="keyword">in</span> kfold.split(train_data):</span><br><span class="line">        random_state+=<span class="number">1</span></span><br><span class="line">        train_x = train_data.loc[train_idx]</span><br><span class="line">        train_y = train_label.loc[train_idx]</span><br><span class="line">        test_x = train_data.loc[val_idx]</span><br><span class="line">        test_y = train_label.loc[val_idx]</span><br><span class="line">        clf=lightgbm</span><br><span class="line">        train_matrix=clf.Dataset(train_x,label=train_y)</span><br><span class="line">        test_matrix=clf.Dataset(test_x,label=test_y)</span><br><span class="line">        </span><br><span class="line">        params=&#123;</span><br><span class="line">                <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;binary&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line">                <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                <span class="string">&#x27;min_child_sample&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">                <span class="string">&#x27;is_unbalace&#x27;</span>:<span class="literal">True</span>,</span><br><span class="line">                <span class="string">&#x27;metric&#x27;</span>: metric,</span><br><span class="line">                <span class="string">&#x27;seed&#x27;</span>: random_state,</span><br><span class="line">                <span class="string">&#x27;silent&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&#x27;nthread&#x27;</span>:-<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">        model=clf.train(params,train_matrix,num_round,valid_sets=test_matrix,early_stopping_rounds=early_stopping_rounds)</span><br><span class="line">        pre_y=model.predict(test_data)</span><br><span class="line">        result.append(pre_y)</span><br><span class="line">        fold+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">test_results=select_by_lgb(train_data,train_label,test_data)</span><br></pre></td></tr></table></figure><h3 id="sklearn-神经网络"><a href="#sklearn-神经网络" class="headerlink" title="sklearn 神经网络"></a><strong>sklearn 神经网络</strong></h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h4><p><strong>K折交叉验证</strong></p><p>因为交叉验证交叉验证的作用主要有两个：模型选择和模型评估。所以使用sklearn.model_selection包，构建交叉验证模型(包中的KFold），将数据分成n份，将1份从数据集中抽出来，作为测试集，用剩下的n-1份建模，使用MLPClassifier模型预测抽取出来的一份，将前面抽取的1份放回，再抽取另1份作为测试集，再进行一次建模预测，循环直到每一份都作为了一次测试集为止，每个样本都被预测了一次且仅一次，计算每个样本的真值和预测值间的误差平方和，即可对模型的可靠性做出适当的评价。</p><p><strong>MLP感知机</strong></p><p>神经网络其实是对生物神经元的模拟和简化，因此基于生物神经元模型可得到多层感知器MLP的基本结构，最典型的MLP包括包括三层：输入层、隐层和输出层，其中输入层输入特征，通过隐层处理数据，再到输出层输出预测结果。</p><h4 id="参数含义-2"><a href="#参数含义-2" class="headerlink" title="参数含义"></a><strong>参数含义</strong></h4><p><strong>K折交叉验证</strong></p><ul><li>n_splits:折叠次数</li><li>shuffle:是否在每次分割之前打乱顺序。</li><li>random_state:随机种子，在shuffle&#x3D;&#x3D;True时使用，默认使用np.random。</li><li>split：返回训练集数据的index与验证集数据的index</li><li>iloc：通过行号来取行数据</li><li>metrics.roc_auc_score：获取auc值</li><li>F1-score：分类问题的一个衡量指标</li></ul><p><strong>MLP感知机</strong></p><ul><li>hidden_layer_sizes：元组，数值表示第i个元素代表第i个隐藏层中的神经元数量。</li><li>solver：用来优化权重，其中值可以是‘lbfgs’，‘sgd’ ，‘adam’，默认为‘adam’，该值表示为机遇随机梯度的优化器，使用默认solver &#x3D;‘adam’在相对较大的数据集上效果比较好，但对小数据集中，对小数据集来说，lbfgs收敛更快效果也更好。</li><li>alpha** :默认0.0001,正则化项参数</li><li>activation:激活函数，其中值可以是‘identity’, ‘logistic’, ‘tanh’, ‘relu’, 默认为‘relu’，该值表示为f(x) &#x3D; max(0, x)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold, StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score, f1_score</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SKFold</span>(<span class="params">train_data,train_label,test_data, model, random_state=<span class="number">1234</span>, n_splits=<span class="number">10</span>,metric=<span class="string">&#x27;auc&#x27;</span>,num_round=<span class="number">10000</span>,early_stopping_rounds=<span class="number">100</span></span>):</span><br><span class="line">    <span class="comment"># 采用分层K折交叉验证训练模型。</span></span><br><span class="line">    kfold = StratifiedKFold(n_splits=n_splits, shuffle=<span class="literal">True</span>, random_state=random_state)</span><br><span class="line">    fold = <span class="number">1</span></span><br><span class="line">    pred_test = []</span><br><span class="line">    <span class="keyword">for</span> train_idx, val_idx <span class="keyword">in</span> kfold.split(train_data, train_label):</span><br><span class="line">        random_state+=<span class="number">1</span></span><br><span class="line">        train_x = train_data.loc[train_idx]</span><br><span class="line">        train_y = train_label.loc[train_idx]</span><br><span class="line">        val_x = train_data.loc[val_idx]</span><br><span class="line">        val_y = train_label.loc[val_idx]</span><br><span class="line">        eval_set = (val_x, val_y)</span><br><span class="line">        clf = model</span><br><span class="line">        model_trained = clf.fit(train_x, train_y)</span><br><span class="line">        <span class="comment"># model_trained = clf.fit(train_x,train_y,early_stopping_rounds=early_stopping_rounds, verbose=False)</span></span><br><span class="line">        <span class="comment"># model_trained = clf.fit(train_x, train_y, eval_set=eval_set, early_stopping_rounds=early_stopping_rounds)</span></span><br><span class="line">        pre_y = model_trained.predict(test_data)</span><br><span class="line">        pred_test.append(pre_y)</span><br><span class="line"></span><br><span class="line">        auc_train = roc_auc_score(train_y, model_trained.predict(train_x))</span><br><span class="line">        auc_val = roc_auc_score(val_y, model_trained.predict(val_x))</span><br><span class="line">        f_score_train = f1_score(train_y, model_trained.predict(train_x))</span><br><span class="line">        f_score_val = f1_score(val_y, model_trained.predict(val_x))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Fold: %d, AUC_train: %.4f, AUC_val: %.4f, F1-score_train: %.4f, F1-score_val: %.4f&#x27;</span>%(fold, </span><br><span class="line">            auc_train, auc_val, f_score_train, f_score_val))</span><br><span class="line">        fold += <span class="number">1</span></span><br><span class="line">    pred_test = pd.DataFrame(pred_test).T</span><br><span class="line">    <span class="comment"># 将5次预测结果求平均值</span></span><br><span class="line">    pred_test[<span class="string">&#x27;average&#x27;</span>] = pred_test.mean(axis=<span class="number">1</span>)</span><br><span class="line">    pred_test[<span class="string">&#x27;mlp_label&#x27;</span>] = pred_test[<span class="string">&#x27;average&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="number">1</span> <span class="keyword">if</span> x&gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pred_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./selectFeatureDataTopInner80_1.csv&#x27;</span>)</span><br><span class="line">train_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;train&#x27;</span>]</span><br><span class="line">test_df = df[df[<span class="string">&#x27;mark&#x27;</span>]==<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_label = train_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">train_data=train_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">test_label = test_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">test_data=test_df.drop([<span class="string">&#x27;mark&#x27;</span>,<span class="string">&#x27;label&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">train_data = scaler.fit_transform(train_data)</span><br><span class="line">test_data = scaler.fit_transform(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考链接：https://zhuanlan.zhihu.com/p/460713425</span></span><br><span class="line">model_MLP = MLPClassifier(solver=<span class="string">&#x27;adam&#x27;</span>,alpha = <span class="number">0.1</span>, hidden_layer_sizes=(<span class="number">64</span>,<span class="number">32</span>,<span class="number">16</span>), activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">result_SKFold_MLP = SKFold(pd.DataFrame(train_data), train_label,pd.DataFrame(test_data), model_MLP, n_splits=<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_MLP = MLPClassifier(solver=<span class="string">&#x27;lbfgs&#x27;</span>,alpha = <span class="number">0.1</span>,power_t=<span class="number">0.5</span>,hidden_layer_sizes=(<span class="number">256</span>,<span class="number">128</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">16</span>), activation=<span class="string">&#x27;identity&#x27;</span>)<span class="comment">#在solver更换为lbfgs，,hidden_layer_sizes增加了更多元组，activation更换为identity,增加power_t参数，默认为0.5，该参数表示逆扩展学习率的指数</span></span><br><span class="line"></span><br><span class="line">SKFold(train_data,train_label,test_data, model, random_state=<span class="number">1234</span>, n_splits=<span class="number">7</span>,metric=<span class="string">&#x27;auc&#x27;</span>,num_round=<span class="number">10000</span>,early_stopping_rounds=<span class="number">100</span>)<span class="comment">#n_splits设置为7</span></span><br></pre></td></tr></table></figure><h3 id="优化结果-2"><a href="#优化结果-2" class="headerlink" title="优化结果"></a><strong>优化结果</strong></h3><p>由于元组数量的增加，牺牲一定的运算时间</p><table><thead><tr><th align="left"></th><th align="left">准确度</th><th align="left">灵敏度</th><th align="left">特异性</th></tr></thead><tbody><tr><td align="left">优化前</td><td align="left">0.575</td><td align="left">0.2</td><td align="left">0.9</td></tr><tr><td align="left">优化后</td><td align="left">0.6</td><td align="left">0.3</td><td align="left">0.9</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><h3 id="PCA-1"><a href="#PCA-1" class="headerlink" title="PCA"></a><strong>PCA</strong></h3><p><a href="https://blog.csdn.net/weixin_41857483/article/details/109603845">https://blog.csdn.net/weixin_41857483/article/details/109603845</a></p><h4 id="孤立森林-1"><a href="#孤立森林-1" class="headerlink" title="孤立森林"></a><strong>孤立森林</strong></h4><p><a href="https://blog.csdn.net/qq_34160248/article/details/124538485">https://blog.csdn.net/qq_34160248/article/details/124538485</a></p><p><a href="https://zhuanlan.zhihu.com/p/74508141">https://zhuanlan.zhihu.com/p/74508141</a></p><h4 id="孤立森林可视化"><a href="#孤立森林可视化" class="headerlink" title="孤立森林可视化"></a><strong>孤立森林可视化</strong></h4><p><a href="http://c.biancheng.net/matplotlib/what-is-matplotlib.html">http://c.biancheng.net/matplotlib/what-is-matplotlib.html</a></p><p><a href="https://blog.csdn.net/weixin_45499440/article/details/123618033">https://blog.csdn.net/weixin_45499440/article/details/123618033</a></p><p><a href="https://blog.csdn.net/coffeetogether/article/details/117838521">https://blog.csdn.net/coffeetogether/article/details/117838521</a></p><h3 id="过采样与欠采样"><a href="#过采样与欠采样" class="headerlink" title="过采样与欠采样"></a><strong>过采样与欠采样</strong></h3><p><a href="https://blog.csdn.net/Dawei_01/article/details/80846371">https://blog.csdn.net/Dawei_01/article/details/80846371</a></p><h4 id="DBSCAN-1"><a href="#DBSCAN-1" class="headerlink" title="DBSCAN"></a><strong>DBSCAN</strong></h4><p><a href="https://blog.csdn.net/wangxiaopeng0329/article/details/53542606">https://blog.csdn.net/wangxiaopeng0329/article/details/53542606</a></p><p><a href="https://zhuanlan.zhihu.com/p/515268801">https://zhuanlan.zhihu.com/p/515268801</a></p><p><a href="https://blog.csdn.net/weixin_31866177/article/details/89416513">https://blog.csdn.net/weixin_31866177/article/details/89416513</a></p><p><strong>置信学习</strong></p><p><a href="https://zhuanlan.zhihu.com/p/394985481">https://zhuanlan.zhihu.com/p/394985481</a></p><p><a href="https://arxiv.org/abs/1911.00068">https://arxiv.org/abs/1911.00068</a></p><p><a href="https://blog.csdn.net/qq874455953/article/details/120174943">https://blog.csdn.net/qq874455953/article/details/120174943</a></p><p><strong>方差过滤</strong></p><p><a href="https://blog.csdn.net/weixin_44210796/article/details/108507267">https://blog.csdn.net/weixin_44210796/article/details/108507267</a></p><h3 id="参数调整-1"><a href="#参数调整-1" class="headerlink" title="参数调整"></a><strong>参数调整</strong></h3><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a><strong>逻辑回归</strong></h4><p><a href="https://www.cnblogs.com/solong1989/p/9620170.html">https://www.cnblogs.com/solong1989/p/9620170.html</a></p><p><a href="https://blog.csdn.net/MR_Trustin/article/details/96614446">https://blog.csdn.net/MR_Trustin/article/details/96614446</a></p><h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a><strong>支持向量机</strong></h4><p><a href="https://ster.im/py_sklearn_2/#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA">https://ster.im/py_sklearn_2/#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA</a></p><h3 id="树模型-1"><a href="#树模型-1" class="headerlink" title="树模型"></a><strong>树模型</strong></h3><p><a href="https://zhuanlan.zhihu.com/p/376485485">https://zhuanlan.zhihu.com/p/376485485</a></p><p><a href="https://www.jianshu.com/p/fe321e478cb4">https://www.jianshu.com/p/fe321e478cb4</a></p><p><a href="https://www.bilibili.com/video/BV1yq4y1z7jK/?spm_id_from=333.337.search-card.all.click&vd_source=b8b7b194f8dd11cd9094eab7f3621690">https://www.bilibili.com/video/BV1yq4y1z7jK</a></p><p><a href="https://www.bilibili.com/video/BV1Bb411S73w?p=1&vd_source=b8b7b194f8dd11cd9094eab7f3621690">https://www.bilibili.com/video/BV1Bb411S73w</a></p><h3 id="sklearn-神经网络-1"><a href="#sklearn-神经网络-1" class="headerlink" title="sklearn 神经网络"></a><strong>sklearn 神经网络</strong></h3><p><a href="https://zhuanlan.zhihu.com/p/63184325">https://zhuanlan.zhihu.com/p/63184325</a></p><p><a href="https://blog.csdn.net/weixin_44491423/article/details/116711606">https://blog.csdn.net/weixin_44491423/article/details/116711606</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 平台上的 TCP 并发服务</title>
      <link href="/2022/06/26/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/"/>
      <url>/2022/06/26/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-平台上的-TCP-并发服务"><a href="#Windows-平台上的-TCP-并发服务" class="headerlink" title="Windows 平台上的 TCP 并发服务"></a>Windows 平台上的 TCP 并发服务</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>编程内容与实验 1 相同，操作系统为 windows。了解 Windows 与 Linux 平台编程环境 的差异，掌握 Winsock 编程接口及编程方法。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>编程内容与实验 1 相同，操作系统为 windows。了解 Windows 与 Linux 平台编程环境 的差异，掌握 Winsock 编程接口及编程方法。</p><h2 id="设计分析"><a href="#设计分析" class="headerlink" title="设计分析"></a>设计分析</h2><ol><li><pre><code>使用无名管道</code></pre></li></ol><p>编程内容与实验 1 相同，操作系统为 windows。了解 Windows 与 Linux 平台编程环境 的差异，掌握 Winsock 编程接口及编程方法。</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>Client.cpp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    fputs(&quot;ip: &quot;, stdout);</span><br><span class="line">    char host[64];</span><br><span class="line">    scanf(&quot;%s&quot;, host);</span><br><span class="line"></span><br><span class="line">    fputs(&quot;port: &quot;, stdout);</span><br><span class="line">    int port;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;port);</span><br><span class="line"></span><br><span class="line">    //建立连接</span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    sockAddr.sin_port = htons(port);</span><br><span class="line">    connect(sock, (SOCKADDR *)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    char msg[MAXBYTE];</span><br><span class="line">    fputs(&quot;input serve second: &quot;, stdout);</span><br><span class="line">    int time;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;time);</span><br><span class="line">    snprintf(msg, MAXBYTE, &quot;%d\n&quot;, time);</span><br><span class="line">    send(sock, msg, strlen(msg) + 1, 0);</span><br><span class="line"></span><br><span class="line">    closesocket(sock);</span><br><span class="line"></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server.c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    fputs(&quot;port: &quot;, stdout);</span><br><span class="line">    int port;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;port);</span><br><span class="line"></span><br><span class="line">    //建立接口初始化设置</span><br><span class="line">    SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    sockAddr.sin_port = htons(port);</span><br><span class="line">    bind(servSock, (SOCKADDR *)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    listen(servSock, 20);</span><br><span class="line"></span><br><span class="line">    //清除僵尸进程</span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    int nSize = sizeof(SOCKADDR);</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        SOCKET clntSock = accept(servSock, (SOCKADDR *)&amp;clntAddr, &amp;nSize);</span><br><span class="line">        char recvBuf[MAXBYTE] = &#123;0&#125;;</span><br><span class="line">        recv(clntSock, recvBuf, MAXBYTE, 0);</span><br><span class="line">        int sec;</span><br><span class="line">        time_t tmval;</span><br><span class="line">        struct tm *tmptr;</span><br><span class="line">        sscanf(recvBuf, &quot;%d&quot;, &amp;sec);</span><br><span class="line">        if (sec &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tmval = time(0);</span><br><span class="line">            tmptr = localtime(&amp;tmval);</span><br><span class="line">            printf(&quot;[%02d:%02d:%02d] server will sleep %d seconds\n&quot;,</span><br><span class="line">                   tmptr-&gt;tm_hour, tmptr-&gt;tm_min,</span><br><span class="line">                   tmptr-&gt;tm_sec, sec);</span><br><span class="line">            sleep(sec);</span><br><span class="line">            tmval = time(0);</span><br><span class="line">            tmptr = localtime(&amp;tmval);</span><br><span class="line">            printf(&quot;[%02d:%02d:%02d] server is wake up\n&quot;,</span><br><span class="line">                   tmptr-&gt;tm_hour, tmptr-&gt;tm_min, tmptr-&gt;tm_sec);</span><br><span class="line">        &#125;</span><br><span class="line">        closesocket(clntSock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closesocket(servSock);</span><br><span class="line"></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/block/QQ%E6%88%AA%E5%9B%BE20220629163908.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间的协调通信</title>
      <link href="/2022/06/25/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/"/>
      <url>/2022/06/25/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间的协调通信"><a href="#进程间的协调通信" class="headerlink" title="进程间的协调通信"></a>进程间的协调通信</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>掌握进程的概念、进程间通信的基本原理、集成间通信的主要类型和各自的特点。。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在linux平台上实现1个父进程、2个子进程，利用管道和共享内存实现两个子进程之间数据快速传送。<br>1)创建一个进程，再创建一对管道、一块共享内存（大于64kB）；<br>2)通过fork（）函数生成2个子进程；<br>3)调试程序，确定父、子进程之间可以双向通信；<br>4)调试程序，确定两个子进程之间可以通过父进程中转实现双向通信；<br>5)调试程序，确定两个子进程都可访问共享内存；<br>6)实现两个子进程之间无冲突地访问共享内存。传送的数据块不小于32kB，为了能够看到演示效果，读&#x2F;写每个字节后都延时0.5ms。</p><h2 id="设计分析"><a href="#设计分析" class="headerlink" title="设计分析"></a>设计分析</h2><ol><li><pre><code>使用无名管道</code></pre></li></ol><p>父进程,用管道1读数据,管道2写数据<br>子进程1用管道1写数据，子进程2用管道2读数据<br>2)进程直接读写内存，不需要任何数据的拷贝，为了在多个进程间交换信息，内核专门留出了一块内存区，由需要访问的进程将其映射到自己私有地址空间，进程直接读写这一内存区而不需要进行数据的拷贝，提高了效率</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>pipe.c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int pipe1[2], pipe2[2];</span><br><span class="line">    int n;</span><br><span class="line">    char cstr[] = &quot;child1 data&quot;;</span><br><span class="line">    char buf[128];</span><br><span class="line"></span><br><span class="line">    // 1个父进程 2个子进程</span><br><span class="line">    if (pipe(pipe1) &lt; 0 || pipe(pipe2) &lt; 0)</span><br><span class="line">        cout &lt;&lt; &quot;pipe error&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pid_t pid1 = fork();</span><br><span class="line">    pid_t pid2 = fork();</span><br><span class="line"></span><br><span class="line">    if (pid1 == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;fork pid1 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid1 &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //父进程,用管道1读数据,管道2写数据</span><br><span class="line">        cout &lt;&lt; &quot;father PID:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">        if (read(pipe1[0], buf, 100) &gt; 0)</span><br><span class="line">            cout &lt;&lt; &quot;father received:&quot; &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        write(pipe2[1], buf, strlen(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid1 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;\npid1:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">        //子进程1用管道1写数据</span><br><span class="line">        close(pipe1[0]); //关闭pipe1读端口</span><br><span class="line">        close(pipe2[0]); //关闭pipe2读端口</span><br><span class="line">        close(pipe2[1]); //关闭pipe2写端口</span><br><span class="line">        write(pipe1[1], cstr, strlen(cstr));</span><br><span class="line">    &#125;</span><br><span class="line">    if (pid2 == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;fork pid2 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //子进程2用管道2读数据</span><br><span class="line">        close(pipe1[0]); //关闭pipe1读端口</span><br><span class="line">        close(pipe1[1]); //关闭pipe1写端口</span><br><span class="line">        close(pipe2[1]); //关闭pipe2写端口</span><br><span class="line">        if (read(pipe2[0], buf, 128) &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;\npid2:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;pid2 receive:&quot; &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>share.c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#define MEM_SIZE 1024</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int shmid;  //内存id</span><br><span class="line">int status; //延时时间</span><br><span class="line"></span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    char *p_addr, *c1_addr, *c2_addr;</span><br><span class="line">    key_t key;</span><br><span class="line">    char *name = (char *)&quot;/dev&quot;;</span><br><span class="line">    char *text = (char *)&quot;hello&quot;;</span><br><span class="line">    int pid1, pid2;</span><br><span class="line"></span><br><span class="line">    key = ftok(name, &#x27;a&#x27;);</span><br><span class="line">    if (key == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;ftok error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    shmid = shmget(key, MEM_SIZE, 0777 | IPC_CREAT);</span><br><span class="line">    if (shmid == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;shmget error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((pid1 = fork()) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;childprocess1 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid1 &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;father PID:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">        //为了能够看到演示效果，读/写每个字节后都延时0.5ms。</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        p_addr = (char *)shmat(shmid, 0, 0);</span><br><span class="line">        cout &lt;&lt; &quot;father received:&quot; &lt;&lt; p_addr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; &quot;child1 PID:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">        c1_addr = (char *)shmat(shmid, 0, 0);</span><br><span class="line">        memset(c1_addr, &#x27;\0&#x27;, 1024);</span><br><span class="line">        strncpy(c1_addr, text, 1024);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    if ((pid2 = fork()) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;childprocess2 failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (pid2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        c2_addr = (char *)shmat(shmid, 0, 0);</span><br><span class="line">        cout &lt;&lt; &quot;\nchild2 PID:&quot; &lt;&lt; getpid() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;child2 received:&quot; &lt;&lt; c2_addr &lt;&lt; endl;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/block/QQ%E6%88%AA%E5%9B%BE20220629163043.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 平台上的 TCP 并发服务</title>
      <link href="/2022/06/24/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/"/>
      <url>/2022/06/24/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-平台上的-TCP-并发服务"><a href="#linux-平台上的-TCP-并发服务" class="headerlink" title="linux 平台上的 TCP 并发服务"></a>linux 平台上的 TCP 并发服务</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>掌握基本套接字函数使用方法、TCP协议工作原理、并发服务原理和编程方法</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在linux平台上实现1个TCP并发服务器，至少可以为10个客户端同时提供服务。<br>1)基于TCP套接字编写服务器端程序代码，然后编译和调试；<br>2)服务器程序要达到：可以绑定从终端输入的IP地址和端口；可以显示每一个进程的进程号；可以显示当前并发执行的进程数量；可以根据客户机要求的服务时间确定进程的生存时间。<br>3)基于TCP套接字编写客户端程序代码，然后编译和调试；<br>4)客户端程序要达到：可以从终端输入服务器的IP地址和端口；可以从终端输入对服务器的服务时间要求。<br>5)联调服务器和客户端，服务器每收到一个连接就新建一个子进程，在子进程中接收客户端的服务时间请求，根据所请求的时间进行延时，然后终止子进程。如：客户端请求服务10s，则服务器的子进程运行10s，然后结束。<br>6)服务器要清除因并发服务而产生的僵尸进程。</p><h2 id="设计分析"><a href="#设计分析" class="headerlink" title="设计分析"></a>设计分析</h2><ol><li>   使用TCP并发，且每次链接创建进程</li><li>   自定义函数sigchld_handler用于清除僵尸进程</li><li>   客户端接受IP 端口（使用学号用于区别）时间，在服务端用sleep来做延时处理。</li></ol><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>client.c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary:</span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-06-24 12:09:12</span><br><span class="line"> * @LastEditTime: 2022-06-25 16:32:15</span><br><span class="line"> * @FilePath: \network\task1\client.c</span><br><span class="line"> */</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">//建立链接</span><br><span class="line">int open_clientfd(char *hostname, int port)</span><br><span class="line">&#123;</span><br><span class="line">    int clientfd;</span><br><span class="line">    struct hostent *hp;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">    if ((clientfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if ((hp = gethostbyname(hostname)) == NULL)</span><br><span class="line">        return -2;</span><br><span class="line">    memset(&amp;serveraddr, 0, sizeof(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    memcpy((char *)&amp;serveraddr.sin_addr.s_addr,</span><br><span class="line">           (char *)hp-&gt;h_addr_list[0],</span><br><span class="line">           hp-&gt;h_length);</span><br><span class="line">    serveraddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    //连接</span><br><span class="line">    if (connect(clientfd, (struct sockaddr *)&amp;serveraddr,</span><br><span class="line">                sizeof(serveraddr)) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    return clientfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以从终端输入服务器的IP地址和端口；可以从终端输入对服务器的服务时间要求。</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int clientfd, port;</span><br><span class="line">    char *host, *seconds;</span><br><span class="line"></span><br><span class="line">    if (argc != 4)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;usage: %s &lt;host&gt; &lt;port&gt; &lt;seconds&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    host = argv[1];</span><br><span class="line">    port = atoi(argv[2]);</span><br><span class="line">    seconds = argv[3];</span><br><span class="line"></span><br><span class="line">    //连接</span><br><span class="line">    if ((clientfd = open_clientfd(host, port)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s\n&quot;, strerror(errno));</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    write(clientfd, seconds, strlen(seconds));</span><br><span class="line">    close(clientfd);</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server.c</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary:</span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-06-24 12:09:12</span><br><span class="line"> * @LastEditTime: 2022-06-25 16:24:33</span><br><span class="line"> * @FilePath: \network\task1\server.c</span><br><span class="line"> */</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define LISTENQ 1024 //监听队列</span><br><span class="line">#define BUFSIZE 1024 //缓冲区</span><br><span class="line"></span><br><span class="line">static int pcnt;</span><br><span class="line"></span><br><span class="line">//据客户机要求的服务时间确定进程的生存时间</span><br><span class="line">void service(int connfd)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[BUFSIZE];</span><br><span class="line">    int seconds;</span><br><span class="line">    time_t tmval;</span><br><span class="line">    const struct tm *tmptr;</span><br><span class="line"></span><br><span class="line">    read(connfd, buf, BUFSIZE);</span><br><span class="line">    sscanf(buf, &quot;%d&quot;, &amp;seconds);</span><br><span class="line">    if (seconds &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        tmval = time(0);</span><br><span class="line">        tmptr = localtime(&amp;tmval);</span><br><span class="line">        printf(&quot;process %d: %d seconds. total child_pid: %d\n&quot;, getpid(), seconds, pcnt);</span><br><span class="line">        sleep(seconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除僵尸进程</span><br><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    time_t tmval;</span><br><span class="line">    const struct tm *tmptr;</span><br><span class="line"></span><br><span class="line">    while ((pid = (waitpid(-1, NULL, WNOHANG))) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        tmval = time(0);</span><br><span class="line">        tmptr = localtime(&amp;tmval);</span><br><span class="line">        printf(&quot;process %d exited. total child_pid: %d\n&quot;, pid, --pcnt);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGCHLD, sigchld_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听</span><br><span class="line">int open_listenfd(int port)</span><br><span class="line">&#123;</span><br><span class="line">    int listenfd, optval = 1;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">    if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    //设置socket</span><br><span class="line">    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,</span><br><span class="line">                   (const void *)&amp;optval, sizeof(int)) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    memset(&amp;serveraddr, 0, sizeof(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = htons((unsigned short)port);</span><br><span class="line"></span><br><span class="line">    //绑定</span><br><span class="line">    if (bind(listenfd, (struct sockaddr *)&amp;serveraddr,</span><br><span class="line">             sizeof(serveraddr)) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if (listen(listenfd, LISTENQ) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    return listenfd;</span><br><span class="line">&#125;</span><br><span class="line">//输入 ip 端口 运行时间</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int listenfd, connfd, port;</span><br><span class="line">    unsigned int clientlen;</span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    if (argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s &lt;port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">    //清除僵尸进程</span><br><span class="line">    signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    if ((listenfd = open_listenfd(port)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s\n&quot;, strerror(errno));</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        clientlen = sizeof(clientaddr);</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            connfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr.sin_addr.s_addr, &amp;clientlen);</span><br><span class="line">        &#125; while (connfd == -1 &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">        if (connfd == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, &quot;%s\n&quot;, strerror(errno));</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((pid = fork()) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, &quot;%s\n&quot;, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pcnt++;</span><br><span class="line">            if (pid == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                close(listenfd);</span><br><span class="line">                service(connfd);</span><br><span class="line">                close(connfd);</span><br><span class="line">                exit(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/block/QQ%E6%88%AA%E5%9B%BE20220629162558.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于MapReduce和Spark的分布式算法设计</title>
      <link href="/2022/06/18/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
      <url>/2022/06/18/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="基于MapReduce和Spark的分布式算法设计"><a href="#基于MapReduce和Spark的分布式算法设计" class="headerlink" title="基于MapReduce和Spark的分布式算法设计"></a>基于MapReduce和Spark的分布式算法设计</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>题目1：<br>输入文件为学生成绩信息，包含了必修课与选修课成绩，格式如下:<br>班级1,姓名1,科目1,必修,成绩1<br>班级2,姓名2,科目1,必修,成绩2<br>班级1,姓名1,科目2,选修,成绩3 </p><hr><p>编写两个Hadoop平台上的MapReduce程序，分别实现如下功能:<br>1.计算每个学生必修课的平均成绩。<br>2.按科目统计每个班的平均成绩。<br>题目2：<br>输入文件的每一行为具有父子&#x2F;父女&#x2F;母子&#x2F;母女&#x2F;关系的一对人名，例如:<br>Tim, Andy<br>Harry,Alice<br>Mark, Louis<br>Andy, Joseph </p><hr><p>假定不会出现重名现象。<br>编写Hadoop平台上的 MapReduce程序，找出所有具有grandchild-grandparent关系的人名组。<br>题目3：<br>输入文件为学生成绩信息，包含了必修课与选修课成绩，格式如下:<br>班级1,姓名1,科目1,必修,成绩1<br>班级⒉,姓名2,科目1,必修,成绩2<br>班级1,姓名1,科目2,选修，成绩3</p><hr><p>编写一个Spark程序，同时实现如下功能:<br>1.计算每个学生必修课的平均成绩。<br>2.统计学生必修课平均成绩在: 90<del>100,80</del>89,70<del>79,60</del>69和 60分以下这5个分数段的人数。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="Conf配置，键值对均为Text格式"><a href="#Conf配置，键值对均为Text格式" class="headerlink" title="Conf配置，键值对均为Text格式"></a>Conf配置，键值对均为Text格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端代码，写完交给ResourceManager框架去执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//conf存储hdfs相关参数</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 通过Conf对象获取Job对象，该job对象会组织所有的该MapReduce程序所有的各种组件</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf, AverageScoreOfRequiredCourses.class.getSimpleName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打成jar执行</span></span><br><span class="line">        <span class="comment">// 设置jar包所在路径</span></span><br><span class="line">        job.setJarByClass(AverageScoreOfRequiredCourses.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据在job类中</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//指定MyMapper类</span></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        <span class="comment">// 对于mapper阶段，输出的key-value分别是：</span></span><br><span class="line">        <span class="comment">// key： 课程 course</span></span><br><span class="line">        <span class="comment">// value： 分数 score</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用MyReducer处理输入的数据</span></span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        <span class="comment">// 对于reducer阶段，reduce方法接收的参数是：</span></span><br><span class="line">        <span class="comment">// key： 课程 course</span></span><br><span class="line">        <span class="comment">// values： 某一门课程对应的所有的score的一个迭代器</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">        <span class="comment">//数据输出到job类中</span></span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交给yarn去执行，直到执行结束才退出本程序</span></span><br><span class="line">        job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h3><p>1.1 在map阶段将输入按照“，”进行分割同时筛选出必修课，把姓名和分数作为键值对，在ruduce聚合时计算平均成绩。<br>对于mapper阶段，输出的key-value分别是：<br>     key： 课程 coursevalue： 分数 score</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt; &#123;</span><br><span class="line">        <span class="type">Text</span> <span class="variable">keyOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        <span class="type">Text</span> <span class="variable">valueOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span></span><br><span class="line">                <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="comment">//split  函数按“，”去分割字符串</span></span><br><span class="line">            String[] splits = value.toString().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (splits[<span class="number">3</span>].equals(<span class="string">&quot;必修&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> splits[<span class="number">1</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">score</span> <span class="operator">=</span> splits[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">                keyOut.set(name);</span><br><span class="line">                valueOut.set(score);</span><br><span class="line"></span><br><span class="line">                context.write(keyOut, valueOut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于reducer阶段，reduce方法接收的参数是：<br>     key： 课程 coursevalues： 某一门课程对应的所有的score的一个迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line">        <span class="type">Text</span> <span class="variable">valueOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        List&lt;Integer&gt; scoreList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;Text&gt; values, Context context)</span></span><br><span class="line">                <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            scoreList.clear();</span><br><span class="line">            <span class="keyword">for</span> (Text t : values) &#123;</span><br><span class="line">                scoreList.add(Integer.valueOf(t.toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sumScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> score : scoreList) &#123;</span><br><span class="line">                sumScore += score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> sumScore * <span class="number">1D</span> / scoreList.size();</span><br><span class="line"></span><br><span class="line">            valueOut.set(<span class="string">&quot;&quot;</span> + avg);</span><br><span class="line">            context.write(key, valueOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1.2 在map阶段将输入按照“，”进行分割，把班级和课程结合作为key，将分数作为value，在ruduce聚合时计算平均成绩。<br>    对于mapper阶段，输出的key-value分别是：<br>&lt;(课程名+班级)，分数&gt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class MyMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; &#123;</span><br><span class="line">        Text keyOut = new Text();</span><br><span class="line">        Text valueOut = new Text();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            // split 函数按“，”去分割字符串</span><br><span class="line">            String[] splits = value.toString().split(&quot;,&quot;);</span><br><span class="line"></span><br><span class="line">            String classes = splits[0];</span><br><span class="line">            String subject = splits[2];</span><br><span class="line">            String score = splits[4];</span><br><span class="line"></span><br><span class="line">            keyOut.set(subject + &quot;\t&quot; + classes + &quot;\t&quot;);</span><br><span class="line">            valueOut.set(score);</span><br><span class="line">            context.write(keyOut, valueOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于reduce阶段，输出的key-value分别是：<br>&lt;(课程名+班级)，某一门课程对应的某班分数的一个迭代器&gt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class MyReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line">        Text valueOut = new Text();</span><br><span class="line">        List&lt;Integer&gt; scoreList = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            scoreList.clear();</span><br><span class="line">            for (Text t : values) &#123;</span><br><span class="line">                scoreList.add(Integer.valueOf(t.toString()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int sumScore = 0;</span><br><span class="line">            for (int score : scoreList) &#123;</span><br><span class="line">                sumScore += score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            double avg = sumScore * 1D / scoreList.size();</span><br><span class="line"></span><br><span class="line">            valueOut.set(&quot;&quot; + avg);</span><br><span class="line">            context.write(key, valueOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h3><p>将输入文件child-parent按照“，”分割，在map阶段导出两个键值对，分别是<br>child – parent和 parent + child，“+&#x2F;-”作为标识方便识别。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void map(LongWritable key, Text value, Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            //split  函数按“，”去分割字符串</span><br><span class="line">            String[] splits = value.toString().split(&quot;,&quot;);</span><br><span class="line">            </span><br><span class="line">            String child = splits[0];</span><br><span class="line">            String parent = splits[1];</span><br><span class="line"></span><br><span class="line">            context.write(new Text(child), new Text(&quot;-&quot; + parent));</span><br><span class="line">context.write(new Text(parent), new Text(&quot;+&quot; + child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // child - parent</span><br><span class="line">        // parent + child</span><br></pre></td></tr></table></figure><p>在reduce聚合阶段识别出map中的两种键值对，将两个键值对的左侧相同的连接，就得到了同一个人的child和parent，那么这两个就是grandchild和grandparent的关系。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class MyReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            ArrayList&lt;Text&gt; s1 = new ArrayList&lt;Text&gt;();</span><br><span class="line">ArrayList&lt;Text&gt; s2 = new ArrayList&lt;Text&gt;();</span><br><span class="line"></span><br><span class="line">for (Text t : values) &#123;</span><br><span class="line">String s = t.toString();</span><br><span class="line">if (s.startsWith(&quot;-&quot;)) &#123;</span><br><span class="line">s1.add(new Text(s.substring(1)));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">s2.add(new Text(s.substring(1)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            //表连接</span><br><span class="line">for (int i = 0; i &lt; s1.size(); i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; s2.size(); j++) &#123;</span><br><span class="line">context.write(s1.get(i), s2.get(j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h3><p>使用pyspark远比java spark简单，java的格式要求过于繁琐。<br>        定义两个函数，分别用作分隔输入文件和将输入分段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置文件</span><br><span class="line">conf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;SparkAvg&quot;)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line">#,分割 返回成绩</span><br><span class="line">def splits(data):</span><br><span class="line">    score = data.split(&quot;,&quot;)</span><br><span class="line">    return (score[1], int(score[4])) </span><br><span class="line"></span><br><span class="line"># 分段函数 将value换为（分数段，1）</span><br><span class="line">def piecewise(x):</span><br><span class="line">    if(x&gt;=90 and x&lt;=100):</span><br><span class="line">        return (&quot;90~100&quot;, 1) </span><br><span class="line">    if(x&gt;=80 and x&lt;=89):</span><br><span class="line">        return (&quot;80~89&quot;, 1) </span><br><span class="line">    if(x&gt;=70 and x&lt;=79):</span><br><span class="line">        return (&quot;70~79&quot;, 1) </span><br><span class="line">    if(x&gt;=60 and x&lt;=69):</span><br><span class="line">        return (&quot;60~69&quot;, 1) </span><br><span class="line">    if(x&lt;60):</span><br><span class="line">        return (&quot;&lt;60:&quot;, 1) </span><br></pre></td></tr></table></figure><p>对于要求1，首先对输入文件预处理，分割并筛选出必修课，在map阶段将键值对转变为&lt;姓名，(成绩，1)&gt;，1代表必修课数量，在reduce阶段就可以得到&lt;姓名，(总成绩，必修课数量)&gt;，用总成绩&#x2F;必修课数量就得到了平均成绩。<br>对于要求2，对要求1得到的键值对按分数分段即&lt;姓名，（分数段，1）&gt;相加则得到了各分数段的人数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 筛选必修课</span><br><span class="line">textData = sc.textFile(&quot;/input/grades.txt&quot;)</span><br><span class="line">lines = textData.filter(lambda line : &quot;必修&quot; in line)\</span><br><span class="line">                .map(lambda x:splits(x))</span><br><span class="line"></span><br><span class="line"># &lt;姓名，(成绩，1)&gt;</span><br><span class="line"># &lt;姓名，(总成绩，必修课数量)&gt;</span><br><span class="line"># &lt;姓名，（平均成绩）&gt;</span><br><span class="line">avgData = lines.mapValues(lambda x : (x,1))\</span><br><span class="line">                .reduceByKey(lambda x,y : (x[0]+y[0],x[1] + y[1]))\</span><br><span class="line">                .mapValues(lambda x : int(x[0] / x[1]))</span><br><span class="line"></span><br><span class="line">avgData.saveAsTextFile(&quot;result1&quot;)</span><br><span class="line"></span><br><span class="line"># 按分数段人数相加</span><br><span class="line">pData = avgData.map(lambda x:piecewise(x[1]))\</span><br><span class="line">                .reduceByKey(lambda x,y : (x+y))</span><br><span class="line"></span><br><span class="line">pData.saveAsTextFile(&quot;result2&quot;)</span><br></pre></td></tr></table></figure><h2 id="主要步骤和实验结果"><a href="#主要步骤和实验结果" class="headerlink" title="主要步骤和实验结果"></a>主要步骤和实验结果</h2><p><img src="/img/block/1.1.png"><br><img src="/img/block/1.2.png"><br><img src="/img/block/2.png"><br><img src="/img/block/3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 实现delete语句</title>
      <link href="/2022/06/15/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2022/06/15/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理实验三：实现delete语句"><a href="#编译原理实验三：实现delete语句" class="headerlink" title="编译原理实验三：实现delete语句"></a>编译原理实验三：实现delete语句</h1><p><strong>姓名</strong>：郭健祥<br><strong>学号</strong>：19030100392<br><strong>阿里云账号</strong>：vgs_31<br><strong>账号ID</strong>：1381522983556954</p><hr><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过本次实验，熟悉数据库的逻辑结构，在语法制导翻译的基础上，完善DBMS系统，实现delete语句的解释执行</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>XDSQL 1.0 simple项目 是对XDSQL 1.0数据库的源码进行修改得到的。它在完整源码的基础上，删除了delete sql对应的yacc代码与相应的查询处理层函数，故它不可直接运行，需要实验者增加部分源码。<br>实验提供的项目中，项目文件夹下包含一个名为 SQLFILE 的文件夹，它用来存储数据库的所有物理文件。其中已有三个表，分别名为 student , course , sc 。如果实验者误删除或修改了文件，可以使用提供的 XDSQL.exe 运行以下脚本即可重新生成 SQLFILE 文件夹.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database xjgl;</span><br><span class="line">use database xjgl;</span><br><span class="line">create table student(sname char(20),sno char(5),sdept char(10),sage int);</span><br><span class="line">insert into student(sname,sno,sdept) values(&#x27;zhangsan&#x27;,&#x27;01&#x27;,&#x27;cs&#x27;);</span><br><span class="line">insert into student(sname,sdept,sage) values(&#x27;xwd&#x27;,&#x27;math&#x27;,19);</span><br><span class="line">insert into student(sname,sno,sage) values(&#x27;ww&#x27;,&#x27;04&#x27;,19);</span><br><span class="line">insert into student values(&#x27;zhg&#x27;,&#x27;05&#x27;,&#x27;cs&#x27;,20);</span><br><span class="line">insert into student values(&#x27;lisi&#x27;,&#x27;02&#x27;,&#x27;ee&#x27;,18);</span><br><span class="line">create table course(cname char(20),cno char(5));</span><br><span class="line">insert into course values(&#x27;database&#x27;,&#x27;01&#x27;);</span><br><span class="line">insert into course values(&#x27;compilers&#x27;,&#x27;02&#x27;);</span><br><span class="line">insert into course values(&#x27;AI&#x27;,&#x27;03&#x27;);</span><br><span class="line">create table sc(sno char(5),cno char(5),grade int);</span><br><span class="line">insert into sc values(&#x27;01&#x27;,&#x27;01&#x27;,89);</span><br><span class="line">insert into sc values(&#x27;04&#x27;,&#x27;03&#x27;,98);</span><br><span class="line">insert into sc values(&#x27;05&#x27;,&#x27;01&#x27;,95);</span><br><span class="line">insert into sc (sno,cno) values(&#x27;01&#x27;,&#x27;02&#x27;);</span><br><span class="line">insert into sc (sno,cno) values(&#x27;02&#x27;,&#x27;03&#x27;);</span><br><span class="line">insert into sc (sno,cno) values(&#x27;05&#x27;,&#x27;02&#x27;);</span><br><span class="line">insert into sc (sno,cno) values(&#x27;05&#x27;,&#x27;03&#x27;);</span><br><span class="line">insert into sc(cno,grade) values(&#x27;02&#x27;,98);</span><br></pre></td></tr></table></figure><p>实验提供者已将所有类都打包为静态链接库文件，并在源码中给出了引用lib文件的预处理语句，实验者只需会正确的调用类和函数即可。<br>请参照实验指导.ppt和类与函数手册.pdf，按照其中的步骤将源码补充完整，使之能成功运行。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>申请云主机，点击创建资源，获得ECS公网IP，登录名和密码。</li><li>打开开始菜单，搜索远程桌面连接并运行，依次填写连接信息。</li><li>点击连接，登录到ECS服务器。第一次连接可能会出现连接失败，等待一两分钟后再次连接即可登<br>录。</li><li>将Git-2.31.1-64-bit.exe复制到云主机（直接复制即可）。</li><li>安装git，安装步骤直接Next即可。</li><li>运行cmd，输入以下指令，将实验源代码下载到云主机。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\</span><br><span class="line">mkdir code</span><br><span class="line">cd code</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git clone https://github.com/flytigerman/XDSQL-1.0.git</span><br></pre></td></tr></table></figure>XDSQL-1.0文件夹内包括以下文件：XDQL 1.0 simple项目文件夹、XDSQL 1.0 complicated项目文件<br>夹、文档文件夹，文档文件夹内包含实验指导.ppt和类与函数手册.pdf。</li><li>将VS2019复制到云主机，安装。安装时只安装使用C++的桌面开发即可，时间大约20分钟。</li><li>打开VS2019，点击右上角的文件-&gt;打开-&gt;项目，打开XDSQL 1.0 simple项目（路径为C:\code\XDSQL-1.0\XDSQL 1.0 simple）</li><li>配置win-flex-bison<br>首先，将win_flex_bison-latest.zip复制到云主机,并解压。<br>随后，在VS2019中，点击右侧（或左侧）项目名，右键-&gt;生成依赖项-&gt;生成自定义。在弹出窗 口中点击查找现有的，然后进入win_flex-bison文件夹下，并依次进入\win_flex_bison_latest\custom_build_rules\文件中，选择”win_flex_bison_custom_build.targets”文件。随后在当前的对话框中，勾选win-flex-bison</li><li>点击项目名，右键-&gt;添加-&gt;现有项，导入scan.l和gram.y文件，这两个文件在项目的XDSQL 1.0<br>simple文件夹路径下。</li><li>打开gram.y文件，根据实验指导.ppt中的步骤，增加文法产生式，补充对新增终结符、非终结符的<br>声明，增加文法产生式的语义动作。引用lib文件和头文件的工作无需实验者完成。完成这些工作后<br>编译gram.y，根据编译信息不断修改yacc代码直到通过编译。</li><li>打开QueryProcessor.cpp，根据实验指导.ppt与类与函数手册.pdf补充deleteTable函数的实现。</li><li>点击生成-&gt;生成解决方案，将scan.l和gram.y转为对应的gram.tab.cpp和scan.flex.cpp文件，并导<br>入项目中；</li><li>运行项目，使用以下sql测试：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from student where sdept=&#x27;ee&#x27;;</span><br><span class="line">select * from student;</span><br><span class="line">delete from student where sdept=&#x27;cs&#x27; and sage &lt;20;</span><br><span class="line">select * from student;</span><br><span class="line">delete from student where sdept=&#x27;cs&#x27; or not(sage&gt;=20);</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#pragma comment(lib,&quot;QueryProcessor_simple.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;values.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;colinf.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;colsinf.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;colvalue.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;colsvalue.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;condition.lib&quot;)</span><br><span class="line">#pragma comment(lib,&quot;conditiontype.lib&quot;)</span><br><span class="line">#include &quot;QueryProcessor.h&quot;</span><br><span class="line">#include &quot;values.h&quot;</span><br><span class="line">#include &quot;colinf.h&quot;</span><br><span class="line">#include &quot;colsinf.h&quot;</span><br><span class="line">#include &quot;colvalue.h&quot;</span><br><span class="line">#include &quot;colsvalue.h&quot;</span><br><span class="line">#include &quot;condition.h&quot;</span><br><span class="line">#include &quot;conditiontype.h&quot;</span><br><span class="line"></span><br><span class="line">extern int yylex(void);</span><br><span class="line">void yyerror(const char* );</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%union&#123;</span><br><span class="line">    /*ID,string,数字字面量的值*/</span><br><span class="line">    class values* value;</span><br><span class="line">    /*单个列列元数据的值*/</span><br><span class="line">    class colinf* single_colinf;</span><br><span class="line">    /*多个列的列元数据*/    </span><br><span class="line">    class colsinf* colsinf;</span><br><span class="line">    /*列的值*/</span><br><span class="line">    class colvalue* colval;</span><br><span class="line">    /*多个列的值*/</span><br><span class="line">    class colsvalue* colsval;</span><br><span class="line">    /*算数表达式的值*/</span><br><span class="line">    int calval;</span><br><span class="line">    /*条件表达式的值*/</span><br><span class="line">    class condition* cond;</span><br><span class="line">    /*比较表达式左,右部分的值*/</span><br><span class="line">    class conditiontype* comp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*终结符 correct*/</span><br><span class="line">%token CREATE USE SHOW DROP DATABASE DATABASES TABLE TABLES INSERT INTO VALUES </span><br><span class="line">%token FROM WHERE SET UPDATE SELECT EXIT DELETE</span><br><span class="line">%token NEWLINE CHAR INT </span><br><span class="line">%token&lt;value&gt; ID STRING NUMBER</span><br><span class="line">%token &#x27;,&#x27; &#x27;;&#x27; &#x27;.&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*非终结符 correct*/</span><br><span class="line">%type&lt;value&gt; dbname tablename colname </span><br><span class="line">%type&lt;single_colinf&gt; col coltype</span><br><span class="line">%type&lt;colsinf&gt; cols </span><br><span class="line">%type&lt;colval&gt; colvalue setconf</span><br><span class="line">%type&lt;colsval&gt; colsvalue colsname tablecols setconfs tables tablecolconf</span><br><span class="line">%type&lt;calval&gt; cal comp_op</span><br><span class="line">%type&lt;cond&gt; condition conditions</span><br><span class="line">%type&lt;comp&gt; comparator tablecol</span><br><span class="line"></span><br><span class="line">/*优先级*/</span><br><span class="line">%left OR</span><br><span class="line">%left AND</span><br><span class="line">%right NOT</span><br><span class="line">%nonassoc &#x27;=&#x27; &#x27;&gt;&#x27; &#x27;&lt;&#x27;</span><br><span class="line">%left &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left &#x27;*&#x27; &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*文法产生式*/</span><br><span class="line">%%</span><br><span class="line">start : line    &#123;&#125;</span><br><span class="line">      | start line    &#123;&#125;</span><br><span class="line">;</span><br><span class="line">line  : NEWLINE    &#123;cout&lt;&lt;endl&lt;&lt;&quot;SQL&gt;&gt;&quot;;&#125;</span><br><span class="line">      | statement NEWLINE    &#123;cout&lt;&lt;endl&lt;&lt;&quot;SQL&gt;&gt;&quot;;&#125;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">statement : createdb&#123;&#125;</span><br><span class="line">      | usedb&#123;&#125;</span><br><span class="line">      | showdb&#123;&#125;</span><br><span class="line">      | dropdb&#123;&#125;</span><br><span class="line">      | createsql&#123;&#125;</span><br><span class="line">      | droptable &#123;&#125;</span><br><span class="line">      | showtables    &#123;&#125;</span><br><span class="line">      | inserttable    &#123;&#125;</span><br><span class="line">      | deletetable    &#123;&#125;</span><br><span class="line">      | updatetable    &#123;&#125;</span><br><span class="line">      | selecttable    &#123;&#125;</span><br><span class="line">      | exit    &#123;&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">exit : EXIT    &#123; return 0;&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*创建数据库*/</span><br><span class="line">createdb : CREATE DATABASE dbname &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.createDB($3-&gt;getStringValue());&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*使用数据库*/</span><br><span class="line">usedb : USE DATABASE dbname &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.useDB($3-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*展示库元数据*/</span><br><span class="line">showdb : SHOW DATABASES &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.showDB();</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*删除数据库*/</span><br><span class="line">dropdb : DROP DATABASE dbname &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.dropDB($3-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">dbname : ID    &#123;    $$=$1;    &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*创建表*/</span><br><span class="line">createsql : CREATE TABLE tablename &#x27;(&#x27; cols &#x27;)&#x27; &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.createTable($3-&gt;getStringValue(),$5-&gt;vec);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">tablename : ID    &#123;$$=$1;&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">cols : col    &#123;</span><br><span class="line">    $$=new colsinf();</span><br><span class="line">    ($$-&gt;vec).push_back($1);</span><br><span class="line">     &#125;</span><br><span class="line">     | cols &#x27;,&#x27; col    &#123;</span><br><span class="line">     $$=$1;</span><br><span class="line">     ($$-&gt;vec).push_back($3);</span><br><span class="line">     &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">col : colname coltype &#123;</span><br><span class="line">    $$=$2;</span><br><span class="line">    $$-&gt;setColName($1-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">colname : ID    &#123;$$=$1;&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">coltype : INT    &#123;</span><br><span class="line">     $$=new colinf();</span><br><span class="line">     $$-&gt;setColType(3);</span><br><span class="line">     $$-&gt;setColLength(4);</span><br><span class="line">    &#125;</span><br><span class="line">    | CHAR &#x27;(&#x27; NUMBER &#x27;)&#x27;    &#123;</span><br><span class="line">     $$=new colinf();</span><br><span class="line">     $$-&gt;setColType(2);</span><br><span class="line">     $$-&gt;setColLength($3-&gt;getDigitsValue());</span><br><span class="line">    &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*删除表*/</span><br><span class="line">droptable : DROP TABLE tablename &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.dropTable($3-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*展示数据库中的表元数据和列元数据*/</span><br><span class="line">showtables : SHOW TABLES &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.showTable();</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将元组插入表*/</span><br><span class="line">inserttable : INSERT INTO tablename VALUES &#x27;(&#x27; colsvalue &#x27;)&#x27; &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.insertTable($3-&gt;getStringValue(),*$6,1);</span><br><span class="line">&#125;</span><br><span class="line">    | INSERT INTO tablename &#x27;(&#x27; colsname &#x27;)&#x27; VALUES &#x27;(&#x27; colsvalue &#x27;)&#x27; &#x27;;&#x27;    &#123;</span><br><span class="line">    /*先将colsename中的表名依次加入colsname的容器中*/</span><br><span class="line">    for(int i=0;i&lt; $9-&gt;vec.size();i++)&#123;</span><br><span class="line">    $9-&gt;vec[i]-&gt;setColName($5-&gt;vec[i]-&gt;getColName());</span><br><span class="line">    &#125;</span><br><span class="line">    /*释放colsname的内存*/</span><br><span class="line">    delete $5;</span><br><span class="line"></span><br><span class="line">    QueryProcessor qp;    </span><br><span class="line">    qp.insertTable($3-&gt;getStringValue(),*$9,2);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">colsname : colname    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    string str=$1-&gt;getStringValue();</span><br><span class="line">    colvalue* cv=new colvalue();</span><br><span class="line">    cv-&gt;setColName(str);</span><br><span class="line">    ($$-&gt;vec).push_back(cv);</span><br><span class="line">&#125;</span><br><span class="line">     | colsname &#x27;,&#x27; colname&#123;</span><br><span class="line">    string str=$3-&gt;getStringValue();</span><br><span class="line">    colvalue* cv=new colvalue();</span><br><span class="line">    cv-&gt;setColName(str);</span><br><span class="line">    $$=$1;</span><br><span class="line">    ($$-&gt;vec).push_back(cv);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">colsvalue : colvalue    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    ($$-&gt;vec).push_back($1);</span><br><span class="line">&#125;</span><br><span class="line">      | colsvalue &#x27;,&#x27; colvalue    &#123;</span><br><span class="line">    $$=$1;</span><br><span class="line">    ($$-&gt;vec).push_back($3);   </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">colvalue : cal    &#123;</span><br><span class="line">    $$=new colvalue();</span><br><span class="line">    $$-&gt;setColType(3);</span><br><span class="line">    $$-&gt;setDigitsValue($1);</span><br><span class="line">&#125;</span><br><span class="line">     | STRING    &#123;</span><br><span class="line">    $$=new colvalue();</span><br><span class="line">    $$-&gt;setColType(2);</span><br><span class="line">    $$-&gt;setStringValue($1-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*算数表达式*/</span><br><span class="line">cal : NUMBER &#123;</span><br><span class="line">    $$=$1-&gt;getDigitsValue();</span><br><span class="line">&#125;</span><br><span class="line">    | cal &#x27;+&#x27; cal &#123;</span><br><span class="line">    $$=$1+$3;    </span><br><span class="line">&#125;</span><br><span class="line">    | cal &#x27;-&#x27; cal &#123;</span><br><span class="line">    $$=$1-$3;</span><br><span class="line">&#125;</span><br><span class="line">    | cal &#x27;*&#x27; cal &#123;</span><br><span class="line">    $$=$1*$3;    </span><br><span class="line">&#125;    | cal &#x27;/&#x27; cal &#123;</span><br><span class="line">    $$=$1/$3;    </span><br><span class="line">&#125;   | &#x27;-&#x27; cal &#123;</span><br><span class="line">    $$=-$2;    </span><br><span class="line">&#125;    | &#x27;(&#x27; cal &#x27;)&#x27; &#123;</span><br><span class="line">    $$=$2;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*逻辑表达式*/</span><br><span class="line">conditions : condition    &#123;</span><br><span class="line">    $$ = $1;</span><br><span class="line">&#125;</span><br><span class="line">    | conditions AND conditions &#123;</span><br><span class="line">    $$ = new condition();</span><br><span class="line">    $$-&gt;iscond = true;</span><br><span class="line">    $$-&gt;comp_cond = 1;</span><br><span class="line">    conditiontype cond1, cond2;</span><br><span class="line">    cond1.cond = $1;</span><br><span class="line">    cond1.type = 4;</span><br><span class="line">    $$-&gt;left = cond1;</span><br><span class="line">    cond2.cond = $3;</span><br><span class="line">    cond2.type=4;</span><br><span class="line">    $$-&gt;right= cond2;</span><br><span class="line">&#125;</span><br><span class="line">    | conditions OR conditions &#123;</span><br><span class="line">    $$ = new condition();</span><br><span class="line">    $$-&gt;iscond = true;</span><br><span class="line">    $$-&gt;comp_cond = 2;</span><br><span class="line">    conditiontype left, right;</span><br><span class="line">    left.cond = $1;</span><br><span class="line">    left.type = 4;</span><br><span class="line">    $$-&gt;left= left;</span><br><span class="line">    right.cond = $3;</span><br><span class="line">    right.type = 4;</span><br><span class="line">    $$-&gt;right= right;</span><br><span class="line">&#125;</span><br><span class="line">    | NOT conditions       &#123;</span><br><span class="line">    $$ = new condition();</span><br><span class="line">    $$-&gt;iscond = true;</span><br><span class="line">    $$-&gt;comp_cond = 3;</span><br><span class="line">    conditiontype right;</span><br><span class="line">    right.cond = $2;</span><br><span class="line">    right.type = 4;</span><br><span class="line">    $$-&gt;right= right;</span><br><span class="line">&#125;</span><br><span class="line">    |&#x27;(&#x27; conditions &#x27;)&#x27;    &#123;</span><br><span class="line">    $$ = $2;    </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/*比较表达式*/</span><br><span class="line">condition : comparator comp_op comparator &#123;</span><br><span class="line">    $$ = new condition();</span><br><span class="line">    $$-&gt;iscond = false;</span><br><span class="line">    $$-&gt;comp_op = $2;</span><br><span class="line">    $$-&gt;left= *$1;</span><br><span class="line">    $$-&gt;right= *$3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">comparator : cal &#123;</span><br><span class="line">    $$ = new conditiontype();</span><br><span class="line">    $$-&gt;type = 3;</span><br><span class="line">    $$-&gt;digits = $1;</span><br><span class="line">&#125;    | STRING &#123;</span><br><span class="line">    $$ = new conditiontype();</span><br><span class="line">    $$-&gt;type = 2;</span><br><span class="line">    $$-&gt;str = $1-&gt;getStringValue();</span><br><span class="line">&#125;    | tablecol &#123;</span><br><span class="line">    $$ = $1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*比较运算符*/</span><br><span class="line">comp_op : &#x27;&lt;&#x27; &#123;</span><br><span class="line">    $$=1;</span><br><span class="line">&#125;    | &#x27;&gt;&#x27; &#123;</span><br><span class="line">    $$=2;</span><br><span class="line">&#125;    | &#x27;&lt;&#x27; &#x27;=&#x27; &#123;</span><br><span class="line">    $$=3;</span><br><span class="line">&#125;    | &#x27;&gt;&#x27; &#x27;=&#x27; &#123;</span><br><span class="line">    $$=4;</span><br><span class="line">&#125;    | &#x27;=&#x27; &#123;</span><br><span class="line">    $$=5;</span><br><span class="line">&#125;    | &#x27;!&#x27; &#x27;=&#x27; &#123;</span><br><span class="line">    $$=6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*表名.列名形式或列名形式 correct*/</span><br><span class="line"></span><br><span class="line">tablecol : colname &#123;</span><br><span class="line">    $$ = new conditiontype();</span><br><span class="line">    $$-&gt;type = 1;</span><br><span class="line">    colvalue* cv = new colvalue();</span><br><span class="line">    string str=$1-&gt;getStringValue();</span><br><span class="line">    cv-&gt;setColName(str);</span><br><span class="line">    $$-&gt;col = cv;</span><br><span class="line">&#125;    | tablename &#x27;.&#x27; colname &#123;</span><br><span class="line">    $$ = new conditiontype();</span><br><span class="line">    $$-&gt;type = 1;</span><br><span class="line">    colvalue* cv = new colvalue();</span><br><span class="line">    cv-&gt;setTableName($1-&gt;getStringValue());</span><br><span class="line">    string str=$3-&gt;getStringValue();</span><br><span class="line">    cv-&gt;setColName(str);</span><br><span class="line">    $$-&gt;col = cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*删除元组 correct*/</span><br><span class="line">deletetable : DELETE FROM tablename &#x27;;&#x27; &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.deleteTable($3-&gt;getStringValue(), NULL);</span><br><span class="line">&#125;</span><br><span class="line">    | DELETE FROM tablename WHERE conditions &#x27;;&#x27; &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.deleteTable($3-&gt;getStringValue(), $5);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*更新元组*/</span><br><span class="line">updatetable : UPDATE tablename SET setconfs &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.updateTable($2-&gt;getStringValue(),*$4,NULL);</span><br><span class="line">&#125;</span><br><span class="line">    | UPDATE tablename SET setconfs WHERE conditions &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;    </span><br><span class="line">    qp.updateTable($2-&gt;getStringValue(),*$4,$6);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*更新赋值的语句*/</span><br><span class="line">setconfs : setconf    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    ($$-&gt;vec).push_back($1);</span><br><span class="line">&#125;</span><br><span class="line">     | setconfs &#x27;,&#x27; setconf    &#123;</span><br><span class="line">    $$=$1;</span><br><span class="line">    ($$-&gt;vec).push_back($3);     </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">setconf : tablecol &#x27;=&#x27; STRING    &#123;</span><br><span class="line">    $$=$1-&gt;col;</span><br><span class="line">    $$-&gt;setStringValue($3-&gt;getStringValue());</span><br><span class="line">&#125;</span><br><span class="line">    | tablecol &#x27;=&#x27; cal    &#123;</span><br><span class="line">    $$=$1-&gt;col;</span><br><span class="line">    $$-&gt;setDigitsValue($3);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">/*纯列名或表名.列名形式*/</span><br><span class="line">tablecols : tablecol    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    ($$-&gt;vec).push_back($1-&gt;col);</span><br><span class="line">&#125;</span><br><span class="line">      | tablecols &#x27;,&#x27; tablecol    &#123;</span><br><span class="line">    $$=$1;</span><br><span class="line">    ($$-&gt;vec).push_back($3-&gt;col);      </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*select table*/</span><br><span class="line">selecttable : SELECT tablecolconf FROM tables &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.selectTable(*$4,*$2,NULL);</span><br><span class="line">&#125;</span><br><span class="line">    | SELECT tablecolconf FROM tables WHERE conditions &#x27;;&#x27;    &#123;</span><br><span class="line">    QueryProcessor qp;</span><br><span class="line">    qp.selectTable(*$4,*$2,$6);    </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">tablecolconf : &#x27;*&#x27;    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    $$-&gt;isALL=true;</span><br><span class="line">&#125;</span><br><span class="line">     | tablecols    &#123;</span><br><span class="line">    $$=$1;    </span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">tables : tablename    &#123;</span><br><span class="line">    $$=new colsvalue();</span><br><span class="line">    colvalue* cv=new colvalue();</span><br><span class="line">    cv-&gt;setTableName($1-&gt;getStringValue());</span><br><span class="line">    ($$-&gt;vec).push_back(cv);</span><br><span class="line">&#125;</span><br><span class="line">       | tables &#x27;,&#x27; tablename    &#123;</span><br><span class="line">    $$=$1;</span><br><span class="line">    colvalue* cv=new colvalue();</span><br><span class="line">    cv-&gt;setTableName($3-&gt;getStringValue());</span><br><span class="line">    ($$-&gt;vec).push_back(cv);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void yyerror(const char* str)&#123;</span><br><span class="line">    cout&lt;&lt;std::string(str)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QueryProcessor-cpp"><a href="#QueryProcessor-cpp" class="headerlink" title="QueryProcessor.cpp"></a>QueryProcessor.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;QueryProcessor.h&quot;</span><br><span class="line"></span><br><span class="line">void QueryProcessor::deleteTable(string tablename, condition* root) &#123;</span><br><span class="line">if (usedatabase.empty()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;error: not using a database&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if ((mdm-&gt;selectDBTable(usedatabase, tablename)).size() == 0) &#123;</span><br><span class="line">cout &lt;&lt; tablename + &quot;is not Exist, Delete Table error&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int rowlength = (mdm-&gt;selectDBTable(usedatabase, tablename))[0]-&gt;getRowLength();</span><br><span class="line">StorageNode sn(SQLFILE + usedatabase + &quot;/&quot; + tablename + &quot;.dat&quot;, rowlength);</span><br><span class="line">if (!root) &#123;</span><br><span class="line">while (!sn.isEOF()) &#123;</span><br><span class="line">char* row = sn.rnd_next();</span><br><span class="line">if (row == NULL) continue;</span><br><span class="line">sn.delete_row();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">root-&gt;addTableName(tablename);</span><br><span class="line">std::vector&lt;colNode*&gt; tablecol = mdm-&gt;selectTableCol(usedatabase, tablename, &quot;&quot;);</span><br><span class="line">colsvalue csv(tablecol);</span><br><span class="line">conditionLinkData(csv.vec, root);</span><br><span class="line">while (!sn.isEOF()) &#123;</span><br><span class="line">char* row = sn.rnd_next();</span><br><span class="line">if (row == NULL) continue;</span><br><span class="line">csv.setCols(row, mdm, usedatabase, tablename);</span><br><span class="line">if (root-&gt;dealConditions().first == true) &#123;</span><br><span class="line">sn.delete_row();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">delete root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/block/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-13%20125803.png"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>三次实验结束，最为困难的是第三次实验，困扰我时间最多，因为要一个个对照手册编写功能，还面领着众多报错，还好看到群里讨论直到要用win_bison –yacc -dv gram.y的命令排错，最后也成功完成了实验，收获颇多。</p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 语法分析</title>
      <link href="/2022/06/13/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2022/06/13/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理实验二：语法分析"><a href="#编译原理实验二：语法分析" class="headerlink" title="编译原理实验二：语法分析"></a>编译原理实验二：语法分析</h1><p><strong>姓名</strong>：郭健祥<br><strong>学号</strong>：19030100392<br><strong>阿里云账号</strong>：vgs_31<br><strong>账号ID</strong>：1381522983556954</p><hr><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解语法分析生成器YACC，学会编写简单的YACC文件，实现对SQL语句中创建数据库、创建表、增删改查语句的识别。</p><h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>YACC是一个语法分析器生成器，接受产生式表示的语法规则，生成识别产生式所描述语言的源程序，不同版本的YACC支持不同的高级语言，如C、C++、Java等。<br>YACC文件和Lex文件相同，也是由三部分组成，分别是定义、规则、用户子程序。其中定义负责描述高级语言的相关声明（如c中的#include）和相关符号定义。规则负责说明语法规则的正则式和对应的相关说明。用户子程序则是用高级语言来表达用户在语法分析中要实现的对应功能。<br>本次实验采用C&#x2F;C++作为YACC生成的源程序语言。所要实现的功能如下：</p><ul><li>创建语句，包括创建数据库和数据表</li><li>插入语句，包括有列名的插入和无列名的插入</li><li>查询语句，包括查找全部、查找指定数据列，有条件的单表查询和有条件的多表查询</li><li>更新语句，包括有条件的更新和无条件的更新</li><li>删除语句，包括有条件的删除和无条件的删除</li></ul><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>连接远程云主机</li><li>将Git-2.33.1-64-bit.exe复制到云主机（直接复制即可）</li><li>安装git，安装步骤直接Next即可</li><li>运行cmd，输入以下指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\</span><br><span class="line">mkdir code</span><br><span class="line">cd code</span><br><span class="line">git clone https://github.com/flytigerman/Compiler-yacc.git</span><br></pre></td></tr></table></figure></li><li>将VS2019复制到云主机，并进行安装，只安装使用C++的桌面开发即可，安装大概20分钟左右。</li><li>打开VS2019，新建C++空项目</li><li>配置win-flex-bison,首先，将win_flex_bison-latest.zip复制到云主机,并解压。随后，在VS2019中，点击右侧（或左侧）新建的项目名，右键-&gt;生成依赖项-&gt;生成自定义。在弹出窗口中点击查找现有的，然后进入win_flex-bison文件夹下，并依次进入\win_flex_bison_latest\custom_build_rules\文件夹中，选择”win_flex_bison_custom_build.targets”文件。随后在当前的对话框中，勾选win-flex-bison</li><li>点击项目名，右键-&gt;添加-&gt;现有项，导入YACC模板文件SQLyacc.l和SQlyacc.y（文件路径为C:\code\Compiler-yacc）</li><li>打开SQLyacc.y，编写YACC语言，实现相关功能</li><li>点击项目名，右键-&gt;生成解决方案。</li><li>将生成的cpp文件和头文件采用第8步的方法加入项目中（都要添加）</li><li>打开项目属性，选择C&#x2F;C++，点击语言，将符合模式改为否，否则会报错</li><li>点击本地运行，生成可执行文件。</li></ol><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><h3 id="lex"><a href="#lex" class="headerlink" title="lex"></a>lex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">/****************************************************************************</span><br><span class="line">SQL.l</span><br><span class="line">ParserWizard generated Lex file.</span><br><span class="line">Date: 2022年6月10日</span><br><span class="line">****************************************************************************/</span><br><span class="line">#include &quot;SQLyacc.tab.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int yylex(void);</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line">%option caseless</span><br><span class="line"></span><br><span class="line">digit    [0-9]</span><br><span class="line">digits    &#123;digit&#125;+</span><br><span class="line">optional_fraction    (&quot;.&quot;&#123;digits&#125;)</span><br><span class="line">letter [a-zA-Z][a-zA-Z0-9_]*</span><br><span class="line">string \&#x27;[^\&#x27;]*\&#x27;</span><br><span class="line">strings \&quot;[^\&quot;]*\&quot;</span><br><span class="line"></span><br><span class="line">create create</span><br><span class="line">drop drop</span><br><span class="line">use use</span><br><span class="line">select select</span><br><span class="line">insert insert</span><br><span class="line">delete delete</span><br><span class="line">update update</span><br><span class="line">from from</span><br><span class="line">where where</span><br><span class="line">into into</span><br><span class="line">values values</span><br><span class="line">set set</span><br><span class="line">database database</span><br><span class="line">table table</span><br><span class="line">and and</span><br><span class="line">or or</span><br><span class="line">int int</span><br><span class="line">double double</span><br><span class="line">char char</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&#123;create&#125; &#123;return CREATE;&#125;</span><br><span class="line">&#123;drop&#125; &#123; return DROP;&#125;</span><br><span class="line">&#123;use&#125; &#123;return USE;&#125;</span><br><span class="line">&#123;select&#125; &#123; return SELECT;&#125; </span><br><span class="line">&#123;insert&#125; &#123; return INSERT;&#125; </span><br><span class="line">&#123;delete&#125; &#123; return DELETE;&#125;</span><br><span class="line">&#123;update&#125; &#123; return UPDATE;&#125;</span><br><span class="line">&#123;from&#125; &#123; return FROM;&#125;</span><br><span class="line">&#123;where&#125; &#123; return WHERE;&#125;</span><br><span class="line">&#123;into&#125; &#123; return INTO;&#125;</span><br><span class="line">&#123;values&#125; &#123; return VALUES;&#125;</span><br><span class="line">&#123;set&#125; &#123; return SET;&#125; </span><br><span class="line">&#123;database&#125; &#123; return DATABASE;&#125; </span><br><span class="line">&#123;table&#125; &#123; return TABLE;&#125; </span><br><span class="line"></span><br><span class="line">&#123;and&#125; &#123; return AND;&#125;</span><br><span class="line">&#123;or&#125; &#123;return OR;&#125;</span><br><span class="line"></span><br><span class="line">&#123;int&#125; &#123; return INT;&#125;</span><br><span class="line">&#123;double&#125; &#123; return DOUBLE;&#125;</span><br><span class="line">&#123;char&#125; &#123; return CHAR;&#125;</span><br><span class="line"></span><br><span class="line">&#123;letter&#125; &#123;return ID;&#125;</span><br><span class="line">&#123;string&#125; &#123;return STRING;&#125;</span><br><span class="line">&#123;strings&#125; &#123;return STRINGS;&#125;</span><br><span class="line">            </span><br><span class="line">&#123;digits&#125; &#123;return INTNUMBER;&#125;</span><br><span class="line">&#123;digits&#125;&#123;optional_fraction&#125; &#123;return DOUBLENUMBER;&#125;</span><br><span class="line"></span><br><span class="line">&quot;+&quot; &#123; return &#x27;+&#x27;; &#125;</span><br><span class="line">&quot;-&quot; &#123; return &#x27;-&#x27;; &#125;</span><br><span class="line">&quot;*&quot; &#123; return &#x27;*&#x27;; &#125;</span><br><span class="line">&quot;/&quot; &#123; return &#x27;/&#x27;; &#125;</span><br><span class="line">&quot;(&quot; &#123; return &#x27;(&#x27;; &#125;</span><br><span class="line">&quot;)&quot; &#123; return &#x27;)&#x27;; &#125;</span><br><span class="line">&quot;,&quot; &#123; return &#x27;,&#x27;; &#125;</span><br><span class="line">&quot;;&quot; &#123; return &#x27;;&#x27;; &#125;</span><br><span class="line">&quot;.&quot; &#123; return &#x27;.&#x27;; &#125;</span><br><span class="line">&quot;&gt;&quot; &#123; return &#x27;&gt;&#x27;; &#125;</span><br><span class="line">&quot;&lt;&quot; &#123; return &#x27;&lt;&#x27;; &#125;</span><br><span class="line">&quot;=&quot; &#123; return &#x27;=&#x27;; &#125;</span><br><span class="line">&quot;!&quot; &#123; return &#x27;!&#x27;; &#125;</span><br><span class="line"></span><br><span class="line">&quot;\n&quot; &#123; return 0; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><h3 id="yacc"><a href="#yacc" class="headerlink" title="yacc"></a>yacc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    #include&lt;stdio.h&gt;</span><br><span class="line">    extern int yylex(void);</span><br><span class="line">    int yyerror(char * msg);</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER CREATE DROP USE SELECT INSERT DELETE UPDATE </span><br><span class="line">%token FROM WHERE INTO VALUES SET DATABASE TABLE AND OR INT </span><br><span class="line">%token DOUBLE CHAR ID STRING STRINGS INTNUMBER DOUBLENUMBER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%left OR</span><br><span class="line">%left AND</span><br><span class="line">%left &#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&quot;!=&quot;,&quot;&gt;=&quot;,&quot;&lt;=&quot;</span><br><span class="line">%left &#x27;+&#x27;,&#x27;-&#x27; </span><br><span class="line">%left &#x27;*&#x27;,&#x27;/&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">statements: statements</span><br><span class="line">    |statement</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">statement: createTablesql    &#123;printf(&quot;识别结果：CREATE TABLE;\n&quot;);&#125;;</span><br><span class="line">    | createDBsql    &#123;printf(&quot;识别结果：CREATE DATABASE;\n&quot;);&#125;;</span><br><span class="line">    | expr </span><br><span class="line">    | useDBsql    &#123;printf(&quot;识别结果：USE DATABASE;\n&quot;);&#125;;</span><br><span class="line">    | insertDBsql    &#123;printf(&quot;识别结果：INSERT\n&quot;);&#125;;</span><br><span class="line">    | selectDBql    &#123;printf(&quot;识别结果：SELECT\n&quot;);&#125;;</span><br><span class="line">    | updateDBsql    &#123;printf(&quot;识别结果：UPDATE\n&quot;);&#125;;</span><br><span class="line">    | deleteDBsql    &#123;printf(&quot;识别结果：DELETE\n&quot;);&#125;;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createTablesql: CREATE TABLE table &#x27;(&#x27;fieldsdefinition &#x27;)&#x27;&#x27;;&#x27;;    </span><br><span class="line">createDBsql: CREATE DATABASE ID&#x27;;&#x27;;    </span><br><span class="line">useDBsql: USE DATABASE ID&#x27;;&#x27;;    </span><br><span class="line">insertDBsql: INSERT INTO table VALUES&#x27;(&#x27;values&#x27;)&#x27;&#x27;;&#x27;    </span><br><span class="line">     |INSERT INTO table&#x27;(&#x27;tables&#x27;)&#x27; VALUES&#x27;(&#x27;values&#x27;)&#x27;&#x27;;&#x27;    </span><br><span class="line">selectDBql: SELECT fields_star FROM tables&#x27;;&#x27;    </span><br><span class="line">    |SELECT fields_star FROM tables WHERE conditions&#x27;;&#x27;    </span><br><span class="line">    ;</span><br><span class="line">updateDBsql: UPDATE table SET updateValues&#x27;;&#x27;    </span><br><span class="line">     |    UPDATE table SET updateValues WHERE conditions&#x27;;&#x27;    </span><br><span class="line">     ;</span><br><span class="line">deleteDBsql:  DELETE FROM table&#x27;;&#x27;    </span><br><span class="line">      |DELETE FROM table WHERE conditions&#x27;;&#x27;    </span><br><span class="line">      ;</span><br><span class="line"></span><br><span class="line">fields_star:    table_fields</span><br><span class="line">    |&#x27;*&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">table_fields:    table_fields&#x27;,&#x27; table_field</span><br><span class="line">    |table_field</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">table_field:    table&#x27;.&#x27;field</span><br><span class="line">    |field    </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">tables:    tables&#x27;,&#x27;table</span><br><span class="line">    |table</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fieldsdefinition:    fieldsdefinition&#x27;,&#x27; field_type ;</span><br><span class="line">    |field_type</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">updateValues:   updateValues&#x27;,&#x27; updateLeft&#x27;=&#x27;value</span><br><span class="line">    |updateLeft&#x27;=&#x27;value</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">updateLeft: ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">values: values&#x27;,&#x27; value</span><br><span class="line">    |value</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">conditions: condition </span><br><span class="line">    | &#x27;(&#x27; conditions &#x27;)&#x27; </span><br><span class="line">    | conditions AND conditions </span><br><span class="line">    | conditions OR conditions</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">condition:  comp_left comp_op comp_right;</span><br><span class="line"></span><br><span class="line">comp_left:  table_field</span><br><span class="line">    |INTNUMBER</span><br><span class="line">    |DOUBLENUMBER</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">comp_right:  table_field</span><br><span class="line">    |INTNUMBER</span><br><span class="line">    |DOUBLENUMBER</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">comp_op: &#x27;&gt;&#x27;|&#x27;&lt;&#x27;|&#x27;=&#x27;|&#x27;!&#x27;&#x27;=&#x27;|&#x27;&gt;&#x27;&#x27;=&#x27;|&#x27;&lt;&#x27;&#x27;=&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">value: INTNUMBER|DOUBLENUMBER|ID;</span><br><span class="line">field_type: field type ; </span><br><span class="line">type: CHAR&#x27;(&#x27;INTNUMBER&#x27;)&#x27; | INT;</span><br><span class="line">table: ID;</span><br><span class="line">field: ID;</span><br><span class="line"></span><br><span class="line">expr    : expr &#x27;+&#x27; expr    &#123; printf(&quot;识别加法\n&quot;); &#125;</span><br><span class="line">    | expr &#x27;-&#x27; expr    &#123; printf(&quot;识别减法\n&quot;); &#125;</span><br><span class="line">    | expr &#x27;*&#x27; expr    &#123; printf(&quot;识别乘法\n&quot;); &#125;</span><br><span class="line">    | expr &#x27;/&#x27; expr    &#123; printf(&quot;识别除法\n&quot;); &#125;</span><br><span class="line">    | &#x27;( expr )&#x27;    &#123; printf(&quot;识别括号\n&quot;); &#125;</span><br><span class="line">    | INTNUMBER    &#123; printf(&quot;识别数字\n&quot;); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;    </span><br><span class="line">    </span><br><span class="line">    while(1)&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int yyerror(char * msg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s is error in line\n&quot;,msg);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p> <img src="/img/block/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-13%20155040.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理 词法分析</title>
      <link href="/2022/06/12/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2022/06/12/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理实验一：词法分析"><a href="#编译原理实验一：词法分析" class="headerlink" title="编译原理实验一：词法分析"></a>编译原理实验一：词法分析</h1><p><strong>姓名</strong>：郭健祥<br><strong>学号</strong>：19030100392<br><strong>阿里云账号</strong>：vgs_31<br><strong>账号ID</strong>：1381522983556954</p><hr><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解词法分析生成器Lex，学会编写简单的Lex文件，实现对SQL语句中整型数、浮点数、变量名、关键字的识别。</p><h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>Lex是一个词法分析器生成器，接受正规式表示的词法规则，生成识别正规式所描述语言的源程序，不同 版本的Lex支持不同的高级语言，如C、C++、Java等。<br>Lex文件由三部分组成，分别是定义、规则、用户子程序。其中定义负责描述高级语言的相关声明（如c 中的#include）和辅助定义正则表达式。规则负责说明词法规则的正则式和对应的相关说明。用户子程 序则是用高级语言来表达用户在词法分析中要实现的对应功能。<br>本次实验采用C&#x2F;C++作为Lex生成的源程序语言。所要实现的功能如下： </p><ul><li>整型数据识别 </li><li>浮点数据识别 </li><li>字符串识别 </li><li>变量名识别 </li><li>关键字识别：create、table、database、use、select、insert、delete、update、from、where、into、values、set、int、double、char、and、or</li></ul><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><ol><li>连接远程云主机<br><img src="/%E5%AE%9E%E9%AA%8C%E4%B8%80/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-13%20153651.png"></li><li>将Git-2.33.1-64-bit.exe复制到云主机（直接复制即可）</li><li>安装git，安装步骤直接Next即可</li><li>运行cmd，输入以下指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\</span><br><span class="line">mkdir code</span><br><span class="line">cd code</span><br><span class="line">git clone https://github.com/flytigerman/Compiler-lex.git</span><br></pre></td></tr></table></figure></li><li>将VS2019复制到云主机，并进行安装，只安装使用C++的桌面开发即可，安装大概20分钟左右。</li><li>打开VS2019，新建C++空项目</li><li>配置win-flex-bison首先，将win_flex_bison-latest.zip复制到云主机,并解压。随后，在VS2019中，点击右侧（或左侧）新建的项目名，右键-&gt;生成依赖项-&gt;生成自定义。在弹出窗口中点击查找现有的，然后进入win_flex-bison文件夹下，并依次进入\win_flex_bison_latest\custom_build_rules\文件夹中，选择”win_flex_bison_custom_build.targets”文件。随后在当前的对话框中，勾选win-flex-bison。</li><li>点击项目名，右键-&gt;添加-&gt;现有项，导入Lex模板文件SQLlex.l（文件路径为C:\code\Compiler_lex）</li><li>编写Lex语言，实现相关功能</li><li>点击项目名，右键-&gt;生成解决方案。</li><li>将生成的cpp文件采用第8步的方法加入项目中</li><li>点击本地运行，生成可执行文件。</li></ol><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%option caseless</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">/****************************************************************************</span><br><span class="line">SQL.l</span><br><span class="line">ParserWizard generated Lex file.</span><br><span class="line"></span><br><span class="line">Date: 2022年6月9日</span><br><span class="line">****************************************************************************/</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ID 0</span><br><span class="line">#define NUMBER 1</span><br><span class="line">#define CREATE 2</span><br><span class="line">#define TABLE 3</span><br><span class="line">#define CHAR 4</span><br><span class="line">#define INT 5</span><br><span class="line">#define INSERT 6</span><br><span class="line">#define UPDATE 7</span><br><span class="line">#define DELETE 8</span><br><span class="line">#define AND 9</span><br><span class="line">#define OR 11</span><br><span class="line">#define DOUBLE 12</span><br><span class="line">#define FROM 13</span><br><span class="line">#define WHERE 14</span><br><span class="line">#define DATABASE 15</span><br><span class="line">#define VALUES 16</span><br><span class="line">#define SET 17</span><br><span class="line">#define USE 18</span><br><span class="line">#define INTO 19</span><br><span class="line">#define SELECT 20</span><br><span class="line"></span><br><span class="line">int yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char [a-zA-Z]</span><br><span class="line">digit [0-9]</span><br><span class="line">digits &#123;digit&#125;+</span><br><span class="line">optional_fraction (&quot;.&quot;&#123;digits&#125;)?</span><br><span class="line">optional_exponent (E[+-]?&#123;digits&#125;)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">create &#123;printf(&quot;CREATE&quot;);return CREATE;&#125;</span><br><span class="line">table &#123;printf(&quot;TABLE&quot;);return TABLE;&#125;</span><br><span class="line">database &#123;printf(&quot;DATABASE&quot;);return DATABASE;&#125;</span><br><span class="line">use &#123;printf(&quot;USE&quot;);return USE;&#125;</span><br><span class="line">select &#123;printf(&quot;SELECT&quot;);return SELECT;&#125;</span><br><span class="line">insert &#123;printf(&quot;INSERT&quot;);return INSERT;&#125;</span><br><span class="line">delete &#123;printf(&quot;DELETE&quot;);return DELETE;&#125;</span><br><span class="line">update &#123;printf(&quot;UPDATE&quot;);return UPDATE;&#125;</span><br><span class="line">from &#123;printf(&quot;FROM&quot;);return FROM;&#125;</span><br><span class="line">where &#123;printf(&quot;WHERE&quot;);return WHERE;&#125;</span><br><span class="line">into &#123;printf(&quot;INTO&quot;);return INTO;&#125;</span><br><span class="line">values &#123;printf(&quot;VALUES&quot;);return VALUES;&#125;</span><br><span class="line">set &#123;printf(&quot;SET&quot;);return SET;&#125;</span><br><span class="line">int &#123;printf(&quot;INT&quot;);return INT;&#125;</span><br><span class="line">double &#123;printf(&quot;DOUBLE&quot;);return DOUBLE;&#125;</span><br><span class="line">char &#123;printf(&quot;CHAR&quot;);return CHAR;&#125;</span><br><span class="line">and &#123;printf(&quot;AND&quot;);return AND;&#125;</span><br><span class="line">or &#123;printf(&quot;OR&quot;);return OR;&#125;</span><br><span class="line"></span><br><span class="line">&#123;char&#125;(&#123;char&#125;|&#123;digit&#125;)* &#123;printf(&quot;变量名:%s&quot;,yytext);return ID;&#125;</span><br><span class="line">&#123;digits&#125;&#123;optional_fraction&#125;&#123;optional_exponent&#125; &#123;printf(&quot;整型数:%s&quot;,yytext);return NUMBER;&#125;</span><br><span class="line">&quot;;&quot;|&quot;(&quot;|&quot;)&quot;|&quot;,&quot;  &#123;printf(&quot;%c&quot;,yytext[0]);return yytext[0];&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">int yywrap() </span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(;;)</span><br><span class="line">    yylex();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/block/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-06-13%20153650.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法java实现</title>
      <link href="/2022/06/03/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD_%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/03/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD_%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="遗传算法java实现"><a href="#遗传算法java实现" class="headerlink" title="遗传算法java实现"></a>遗传算法java实现</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p><img src="/img/block/QQ%E6%88%AA%E5%9B%BE20220629161610.png"></p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>GA.java</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary: 遗传算法解二元函数最大值</span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-06-03 17:08:46</span><br><span class="line"> * @LastEditTime: 2022-06-18 16:11:36</span><br><span class="line"> * @FilePath: \人工智能导论\GA\src\GA\GA.java</span><br><span class="line"> */</span><br><span class="line">package GA;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import static java.lang.Math.*;</span><br><span class="line"></span><br><span class="line">public class GA &#123;</span><br><span class="line"></span><br><span class="line">    public static final int RANDOMMAX = 32767; // 防止越界</span><br><span class="line">    public static final double PI = 3.1415926535897932384626433832795;</span><br><span class="line"></span><br><span class="line">    public ArrayList&lt;String&gt; pop = new ArrayList&lt;&gt;();// 存储迭代结果</span><br><span class="line">    public static final int NUMBER = 1000;// 种群规模</span><br><span class="line">    private double pc = 0.25;// 交叉概率</span><br><span class="line">    private double pm = 0.01;// 变异概率</span><br><span class="line"></span><br><span class="line">    private int length = 39;// 编码长度</span><br><span class="line">    private int x1length = 21;// 编码长度</span><br><span class="line">    private int x2length = 18;// 编码长度</span><br><span class="line"></span><br><span class="line">    // 变量界限</span><br><span class="line">    private double x1leftBound = -2.9;</span><br><span class="line">    private double x1rightBound = 12.0;</span><br><span class="line">    private double x2leftBound = 4.2;</span><br><span class="line">    private double x2rightBound = 5.7;</span><br><span class="line"></span><br><span class="line">    String maxString;// 最大个体基因</span><br><span class="line">    private int t; // 进化代数</span><br><span class="line"></span><br><span class="line">    // 迭代</span><br><span class="line">    public void incre_t() &#123;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setT(int t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化种群</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        for (int i = 0; i &lt; NUMBER; i++) &#123;</span><br><span class="line">            String s = &quot;&quot;;</span><br><span class="line">            for (int j = 0; j &lt; length; j++) &#123;</span><br><span class="line">                // 生成随机数偶数置1 奇数置0</span><br><span class="line">                int rr = r.nextInt();</span><br><span class="line">                if (rr % 2 == 0)</span><br><span class="line">                    s = s + &quot;1&quot;;</span><br><span class="line">                else</span><br><span class="line">                    s = s + &quot;0&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            pop.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二进制字符串转化成整形</span><br><span class="line">    public static int transform(String s) &#123;</span><br><span class="line">        int n = 0;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            n = n * 2 + s.charAt(i) - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解码并计算适应度</span><br><span class="line">    public Individual fitness(String s) &#123;</span><br><span class="line">        Individual t = new Individual();</span><br><span class="line">        double x1a = x1leftBound;</span><br><span class="line">        double x1b = x1rightBound;</span><br><span class="line">        double x2a = x2leftBound;</span><br><span class="line">        double x2b = x2rightBound;</span><br><span class="line">        // 截取x1的字符串</span><br><span class="line">        String s1 = s.substring(0, x1length);</span><br><span class="line">        String s2 = s.substring(x1length, length);</span><br><span class="line">        int t1 = transform(s1);</span><br><span class="line">        int t2 = transform(s2);</span><br><span class="line"></span><br><span class="line">        // 带入函数值</span><br><span class="line">        t.setX1(x1a + (x1b - x1a) * t1 / (pow(2.0, x1length) - 1));</span><br><span class="line">        t.setX2(x2a + (x2b - x2a) * t2 / (pow(2.0, x2length) - 1));</span><br><span class="line">        t.setFit(21.5 + t.getX1() * sin(4 * PI * t.getX1()) + t.getX2() * sin(20 * PI * t.getX2()));</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 轮盘赌选择</span><br><span class="line">    public ArrayList&lt;String&gt; choose(ArrayList&lt;String&gt; population, int x) &#123;</span><br><span class="line">        double fitnessSum = 0;// 总适应度</span><br><span class="line">        ArrayList&lt;Double&gt; q = new ArrayList&lt;&gt;();// 圆盘分布率</span><br><span class="line">        ArrayList&lt;Individual&gt; indiList = new ArrayList&lt;&gt;();// 适应度数组</span><br><span class="line">        ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();// 选择结果</span><br><span class="line">        ArrayList&lt;Double&gt; random = new ArrayList&lt;&gt;();// 随机数数组</span><br><span class="line">        double p = 0;</span><br><span class="line"></span><br><span class="line">        // 获取随机数</span><br><span class="line">        for (int i = 0; i &lt; x; i++) &#123;</span><br><span class="line">            Random r = new Random();</span><br><span class="line">            // 加入下一个伪随机数</span><br><span class="line">            random.add(r.nextDouble());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算总适应度</span><br><span class="line">        for (int i = 0; i &lt; population.size(); i++) &#123;</span><br><span class="line">            Individual Indi = fitness(population.get(i));</span><br><span class="line">            indiList.add(Indi);</span><br><span class="line">            fitnessSum = fitnessSum + Indi.getFit();</span><br><span class="line">        &#125;</span><br><span class="line">        // 分布圆盘</span><br><span class="line">        for (int i = 0; i &lt; population.size(); i++) &#123;</span><br><span class="line">            Individual Indi = indiList.get(i);</span><br><span class="line">            p = p + Indi.getFit() / fitnessSum;</span><br><span class="line">            if (i == population.size() - 1)</span><br><span class="line">                q.add(1.0);</span><br><span class="line">            else</span><br><span class="line">                q.add(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; random.size(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; q.size(); j++) &#123;</span><br><span class="line">                if (q.get(j) != 1.0 &amp;&amp; random.get(i) &gt; q.get(j) &amp;&amp; random.get(i) &lt;= q.get(j + 1)) &#123;</span><br><span class="line">                    result.add(population.get(j + 1));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 两点交叉</span><br><span class="line">    public ArrayList&lt;String&gt; crossover(ArrayList&lt;String&gt; population) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i + 1 &lt; population.size(); i = i + 2) &#123;</span><br><span class="line">            String s1 = population.get(i);</span><br><span class="line">            String s2 = population.get(i + 1);</span><br><span class="line">            // 随机数控制交叉概率</span><br><span class="line">            Random r = new Random();</span><br><span class="line">            if (r.nextDouble() &lt; pc) &#123;</span><br><span class="line">                int i1 = (int) (r.nextDouble() * length);</span><br><span class="line">                int i2 = (int) (r.nextDouble() * length);</span><br><span class="line">                if (i1 &lt; i2) &#123;</span><br><span class="line">                    String sub1 = s1.substring(i1, i2 + 1);</span><br><span class="line">                    String sub2 = s2.substring(i1, i2 + 1);</span><br><span class="line">                    s1 = s1.substring(0, i1) + sub2 + s1.substring(i2 + 1, length);</span><br><span class="line">                    s2 = s2.substring(0, i1) + sub1 + s2.substring(i2 + 1, length);</span><br><span class="line">                    result.add(s1);</span><br><span class="line">                    result.add(s2);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (i1 &gt; i2) &#123;</span><br><span class="line">                        String sub1 = s1.substring(i2, i1 + 1);</span><br><span class="line">                        String sub2 = s2.substring(i2, i1 + 1);</span><br><span class="line">                        s1 = s1.substring(0, i2) + sub2 + s1.substring(i1 + 1, length);</span><br><span class="line">                        s2 = s2.substring(0, i2) + sub1 + s2.substring(i1 + 1, length);</span><br><span class="line">                        result.add(s1);</span><br><span class="line">                        result.add(s2);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.add(s1);</span><br><span class="line">                        result.add(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result.add(s1);</span><br><span class="line">                result.add(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单点变异</span><br><span class="line">    public String mutation(String s) &#123;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        // 0 1交换</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            if (r.nextDouble() &lt; pm) &#123;</span><br><span class="line">                if (s.charAt(i) == &#x27;0&#x27;) &#123;</span><br><span class="line">                    StringBuilder strBuilder = new StringBuilder(s);</span><br><span class="line">                    strBuilder.setCharAt(i, &#x27;1&#x27;);</span><br><span class="line">                    s = strBuilder.toString();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    StringBuilder strBuilder = new StringBuilder(s);</span><br><span class="line">                    strBuilder.setCharAt(i, &#x27;0&#x27;);</span><br><span class="line">                    s = strBuilder.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回本轮适应度值最大的个体</span><br><span class="line">    public Individual print(ArrayList&lt;String&gt; generation) &#123;</span><br><span class="line">        Individual max = new Individual();</span><br><span class="line">        for (int i = 0; i &lt; generation.size(); i++) &#123;</span><br><span class="line">            Individual individual = fitness(generation.get(i));</span><br><span class="line">            if (individual.getFit() &gt; max.getFit()) &#123;</span><br><span class="line">                max = individual;</span><br><span class="line">                maxString = generation.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GA aiWork = new GA();</span><br><span class="line">        Individual Max = new Individual();</span><br><span class="line">        aiWork.init();</span><br><span class="line">        int j = 0;</span><br><span class="line"></span><br><span class="line">        while (aiWork.getT() &lt; 100) &#123;</span><br><span class="line">            double max1 = 0;</span><br><span class="line">            double max2 = 0;</span><br><span class="line">            String s1 = null;</span><br><span class="line">            String s2 = null;</span><br><span class="line">            Individual max;</span><br><span class="line">            ArrayList&lt;String&gt; pop1, pop2, popNew, pop3 = new ArrayList&lt;&gt;();</span><br><span class="line">            pop1 = aiWork.choose(aiWork.pop, NUMBER);// 轮盘赌</span><br><span class="line">            pop2 = aiWork.crossover(pop1);// 两点交叉</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; pop2.size(); i++) &#123;</span><br><span class="line">                String s = aiWork.mutation(pop2.get(i));</span><br><span class="line">                pop3.add(s);// 单点变异</span><br><span class="line">                double d = aiWork.fitness(pop2.get(i)).getFit();</span><br><span class="line"></span><br><span class="line">                if (d &gt; max1) &#123;</span><br><span class="line">                    s1 = pop2.get(i);</span><br><span class="line">                    max1 = d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; pop3.size(); i++) &#123;</span><br><span class="line">                double d = aiWork.fitness(pop3.get(i)).getFit();</span><br><span class="line">                if (d &gt; max2) &#123;</span><br><span class="line">                    s2 = pop3.get(i);</span><br><span class="line">                    max2 = d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // popNew存储最大适应度结果</span><br><span class="line">            popNew = aiWork.choose(aiWork.pop, NUMBER - 2);</span><br><span class="line">            popNew.add(s1);</span><br><span class="line">            popNew.add(s2);</span><br><span class="line">            aiWork.pop = popNew;</span><br><span class="line">            max = aiWork.print(aiWork.pop);</span><br><span class="line">            if (max.getFit() &gt; Max.getFit()) &#123;</span><br><span class="line">                System.out.println((j + 1) + &quot;  x1:&quot; + max.getX1() + &quot;  x2:&quot; + max.getX2() + &quot;  max:&quot; + max.getFit());</span><br><span class="line">                Max = max;</span><br><span class="line">                aiWork.pop.add(aiWork.maxString);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println((j + 1) + &quot;  x1:&quot; + Max.getX1() + &quot;  x2:&quot; + Max.getX2() + &quot;  max:&quot; + Max.getFit());</span><br><span class="line">            &#125;</span><br><span class="line">            aiWork.incre_t();</span><br><span class="line"></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(aiWork.maxString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>individual.java</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary: </span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-06-03 15:58:42</span><br><span class="line"> * @LastEditTime: 2022-06-03 17:05:09</span><br><span class="line"> * @FilePath: \homework\AI\src\GA\Individual.java</span><br><span class="line"> */</span><br><span class="line">package GA;</span><br><span class="line"></span><br><span class="line">public class Individual &#123;</span><br><span class="line"></span><br><span class="line">    double x1, x2;</span><br><span class="line">    double fit;</span><br><span class="line"></span><br><span class="line">    public double getFit() &#123;</span><br><span class="line">        return fit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX1(double d) &#123;</span><br><span class="line">        this.x1 = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX2(double d) &#123;</span><br><span class="line">        this.x2 = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getX1() &#123;</span><br><span class="line">        return x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getX2() &#123;</span><br><span class="line">        return x2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFit(double d) &#123;</span><br><span class="line">        this.fit = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学一考纲</title>
      <link href="/2022/03/27/%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E4%B8%80/"/>
      <url>/2022/03/27/%E8%B5%84%E6%96%99/%E6%95%B0%E5%AD%A6%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="考研考试形式和试卷结构"><a href="#考研考试形式和试卷结构" class="headerlink" title="考研考试形式和试卷结构"></a><strong>考研考试形式和试卷结构</strong></h1><p>一、试卷满分及考试时间：试卷满分为150分，考试时间为180分钟.</p><p>二、答题方式：答题方式为闭卷、笔试.</p><p>三、试卷内容结构：高等教学约60%;线性代数约20%;概率论与数理统计约20%.</p><p>四、试卷题型结构：</p><p>单选题10小题，每小题5分，共50分</p><p>填空题 6小题，每小题5分，共30分</p><p>解答题(包括证明题)7 小题，共70分</p><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a><strong>高等数学</strong></h1><h2 id="一、函数、极限、连续"><a href="#一、函数、极限、连续" class="headerlink" title="一、函数、极限、连续"></a>一、函数、极限、连续</h2><p>函数的概念及表示法</p><p>函数的有界性、单调性、周期性和奇偶性</p><p>复合函数、反函数、分段函数和隐函数</p><p>基本初等函数的性质及其图形、初等函数、函数关系的建立</p><p>数列极限与函数极限的定义及其性质</p><p>函数的左极限和右极限</p><p>无穷小量和无穷大量的概念及其关系</p><p>无穷小量的性质及无穷小量的比较</p><p>极限的四则运算</p><p>极限存在的两个准则</p><p>单调有界准则和夹逼准则</p><p>两个重要极限：</p><p><img src="http://cdn.download.chinakaoyan.com/wwwfile/2021/20210917102100.png" alt="img"></p><p><img src="http://cdn.download.chinakaoyan.com/wwwfile/2021/20210917102101.png" alt="img"></p><p>函数连续的概念</p><p>函数间断点的类型</p><p>初等函数的连续性</p><p>闭区间上连续函数的性质.</p><p>考试要求</p><p>1.理解函数的概念，掌握函数的表示法，会建立应用问题的函数关系.</p><p>2.了解函数的有界性、单调性、周期性和奇偶性.</p><p>3.理解复合函数及分段函数的概念，了解反函数及隐函数的概念.</p><p>4.掌握基本初等函数的性质及其图形，了解初等函数的概念.</p><p>5.理解极限的概念，理解函数左极限与右极限的概念以及函数极限存在与左极限、右极限之间的关系.</p><p>6.掌握极限的性质及四则运算法则.</p><p>7.掌握极限存在的两个准则，并会利用它们求极限，掌握利用两个重要极限求极限的方法.</p><p>8.理解无穷小量、无穷大量的概念，掌握无穷小量的比较方法，会用等价无穷小量求极限.</p><p>9.理解函数连续性的概念(含左连续与右连续)，会判别函数间断点的类型.</p><p>10.了解连续函数的性质和初等函数的连续性，理解闭区间上连续函数的性质(有界性、最大值和最小值定理、介值定理)，并会应用这些性质.</p><h2 id="二、一元函数微分学"><a href="#二、一元函数微分学" class="headerlink" title="二、一元函数微分学"></a>二、一元函数微分学</h2><p>导数和微分的概念</p><p>导数的几何意义和物理意义</p><p>函数的可导性与连续性之间的关系</p><p>平面曲线的切线和法线</p><p>导数和微分的四则运算</p><p>基本初等函数的导数</p><p>复合函数、反函数、隐函数以及参数方程所确定的函数的微分法</p><p>高阶导数、一阶微分形式的不变性</p><p>微分中值定理</p><p>洛必达(L’Hospital)法则</p><p>函数单调性的判别</p><p>函数的极值</p><p>函数图形的凹凸性</p><p>拐点及渐近线</p><p>函数图形的描绘函数的最大值与最小值</p><p>弧微分及曲率的概念</p><p>曲率圆与曲率半径</p><p>考试要求</p><p>1.理解导数和微分的概念，理解导数与微分的关系，理解导数的几何意义，会求平面曲线的切线方程和法线方程，了解导数的物理意义，会用导数描述一些物理量，理解函数的可导性与连续性之间的关系.</p><p>2.掌握导数的四则运算法则和复合函数的求导法则，掌握基本初等函数的导数公式.了解微分的四则运算法则和一阶微分形式的不变性，会求函数的微分.</p><p>3.了解高阶导数的概念，会求简单函数的高阶导数.</p><p>4.会求分段函数的导数，会求隐函数和由参数方程所确定的函数以及反函数的导数.</p><p>5.理解并会用罗尔(Rolle)定理、拉格朗日(Lagrange)中值定理和泰勒(Taylor)定理，了解并会用柯西(Cauchy)中值定理.</p><p>6.掌握用洛必达法则求未定式极限的方法.</p><p>7.理解函数的极值概念，掌握用导数判断函数的单调性和求函数极值的方法，掌握函数最大值和最小值的求法及其应用.</p><p>8.会用导数判断函数图形的凹凸性(注：在区间内，设函数具有二阶导数.当时，的图形是凹的;当时，的图形是凸的)，会求函数图形的拐点以及水平、铅直和斜渐近线，会描绘函数的图形.</p><p>9.了解曲率、曲率圆与曲率半径的概念，会计算曲率和曲率半径.</p><h2 id="三、一元函数积分学"><a href="#三、一元函数积分学" class="headerlink" title="三、一元函数积分学"></a>三、一元函数积分学</h2><p>原函数和不定积分的概念</p><p>不定积分的基本性质</p><p>基本积分公式</p><p>定积分的概念和基本性质</p><p>定积分中值定理</p><p>积分上限的函数及其导数</p><p>牛顿-莱布尼茨(Newton-Leibniz)公式</p><p>不定积分和定积分的换元积分法与分部积分法</p><p>有理函数、三角函数的有理式和简单无理函数的积分</p><p>反常(广义)积分</p><p>定积分的应用.</p><p>考试要求</p><p>1.理解原函数的概念，理解不定积分和定积分的概念.</p><p>2.掌握不定积分的基本公式，掌握不定积分和定积分的性质及定积分中值定理，掌握换元积分法与分部积分法.</p><p>3.会求有理函数、三角函数有理式和简单无理函数的积分.</p><p>4.理解积分上限的函数，会求它的导数，掌握牛顿-莱布尼茨公式.</p><p>5.理解反常积分的概念，了解反常积分收敛的比较判别法，会计算反常积分.</p><p>6.掌握用定积分表达和计算一些几何量与物理量(平面图形的面积、平面曲线的弧长、旋转体的体积及侧面积、平行截面面积为已知的立体体积、功、引力、压力、质心、形心等)及函数的平均值.</p><h2 id="四、向量代数和空间解析几何"><a href="#四、向量代数和空间解析几何" class="headerlink" title="四、向量代数和空间解析几何"></a>四、向量代数和空间解析几何</h2><p>向量的概念</p><p>向量的线性运算</p><p>向量的数量积和向量积</p><p>向量的混合积</p><p>两向量垂直及平行的条件</p><p>两向量的夹角</p><p>向量的坐标表达式及其运算</p><p>单位向量、方向数与方向余弦</p><p>曲面方程和空间曲线方程的概念</p><p>平面方程、直线方程</p><p>平面与平面及平面与直线及直线与直线的夹角以及平行和垂直的条件</p><p>点到平面和点到直线的距离</p><p>球面、柱面、旋转曲面、常用的二次曲面方程及其图形</p><p>空间曲线的参数方程和一般方程</p><p>空间曲线在坐标面上的投影曲线方程.</p><p>考试要求</p><p>1.理解空间直角坐标系，理解向量的概念及其表示.</p><p>2.掌握向量的运算(线性运算、数量积、向量积、混合积)，了解两个向量垂直、平行的条件.</p><p>3.理解单位向量、方向数与方向余弦、向量的坐标表达式，掌握用坐标表达式进行向量运算的方法.</p><p>4.掌握平面方程和直线方程及其求法.</p><p>5.会求平面与平面、平面与直线、直线与直线之间的夹角，并会利用平面、直线的相互关系(平行、垂直、相交等))解决有关问题.</p><p>6.会求点到直线以及点到平面的距离.</p><p>7.了解曲面方程和空间曲线方程的概念.</p><p>8.了解常用二次曲面的方程及其图形，会求简单的柱面和旋转曲面的方程.</p><p>9.了解空间曲线的参数方程和一般方程.了解空间曲线在坐标平面上的投影，并会求该投影曲线的方程.</p><h2 id="五、多元函数微分学"><a href="#五、多元函数微分学" class="headerlink" title="五、多元函数微分学"></a>五、多元函数微分学</h2><p>多元函数的概念</p><p>二元函数的几何意义</p><p>二元函数的极限与连续的概念</p><p>有界闭区域上多元连续函数的性质</p><p>多元函数的偏导数和全微分</p><p>全微分存在的必要条件和充分条件.</p><p>多元复合函数</p><p>隐函数的求导法</p><p>二阶偏导数</p><p>方向导数和梯度</p><p>空间曲线的切线和法平面</p><p>曲面的切平面和法线</p><p>二元函数的二阶泰勒公式</p><p>多元函数的极值和条件极值</p><p>多元函数的最大值、最小值及其简单应用.</p><p>考试要求</p><p>1.理解多元函数的概念，理解二元函数的几何意义.</p><p>2.了解二元函数的极限与连续的概念以及有界闭区域上连续函数的性质.</p><p>3.理解多元函数偏导数和全微分的概念，会求全微分，了解全微分存在的必要条件和充分条件，了解全微分形式的不变性.</p><p>4.理解方向导数与梯度的概念，并掌握其计算方法.</p><p>5.掌握多元复合函数一阶、二阶偏导数的求法.</p><p>6.了解隐函数存在定理，会求多元隐函数的偏导数.</p><p>7.了解空间曲线的切线和法平面及曲面的切平面和法线的概念，会求它们的方程.</p><p>8.了解二元函数的二阶泰勒公式.</p><p>9.理解多元函数极值和条件极值的概念，掌握多元函数极值存在的必要条件，了解二元函数极值存在的充分条件，会求二元函数的极值，会用拉格朗日乘数法求条件极值，会求简单多元函数的最大值和最小值，并会解决一些简单的应用问题.</p><h2 id="六、多元函数积分学"><a href="#六、多元函数积分学" class="headerlink" title="六、多元函数积分学"></a>六、多元函数积分学</h2><p>二重积分与三重积分的概念、性质、计算和应用</p><p>两类曲线积分的概念及性质及计算</p><p>两类曲线积分的关系</p><p>格林(Green)公式</p><p>平面曲线积分与路径无关的条件</p><p>二元函数全微分的原函数</p><p>两类曲面积分的概念及性质及计算</p><p>两类曲面积分的关系</p><p>高斯(Gauss)公式</p><p>斯托克斯(Stokes)公式</p><p>散度和旋度的概念及计算</p><p>曲线积分和曲面积分的应用.</p><p>考试要求</p><p>1.理解二重积分、三重积分的概念，了解重积分的性质，了解二重积分的中值定理.</p><p>2.掌握二重积分的计算方法(直角坐标、极坐标)，会计算三重积分(直角坐标、柱面坐标、球面坐标).</p><p>3.理解两类曲线积分的概念，了解两类曲线积分的性质及两类曲线积分的关系.</p><p>4.掌握计算两类曲线积分的方法.</p><p>5.掌握格林公式并会运用平面曲线积分与路径无关的条件，会求二元函数全微分的原函数.</p><p>6.了解两类曲面积分的概念、性质及两类曲面积分的关系，掌握计算两类曲面积分的方法，掌握用高斯公式计算曲面积分的方法，并会用斯托克斯公式计算曲线积分.</p><p>7.了解散度与旋度的概念，并会计算.</p><p>8.会用重积分、曲线积分及曲面积分求一些几何量与物理量(平面图形的面积、体积、曲面面积、弧长、质量、质心、、形心、转动惯量、引力、功及流量等).</p><h2 id="七、无穷级数"><a href="#七、无穷级数" class="headerlink" title="七、无穷级数"></a>七、无穷级数</h2><p>常数项级数的收敛与发散的概念</p><p>收敛级数的和的概念</p><p>级数的基本性质与收敛的必要条件</p><p>几何级数与级数及其收敛性</p><p>正项级数收敛性的判别法</p><p>交错级数与莱布尼茨定理</p><p>任意项级数的绝对收敛与条件收敛</p><p>函数项级数的收敛域与和函数的概念</p><p>幂级数及其收敛半径</p><p>收敛区间(指开区间)和收敛域</p><p>幂级数的和函数</p><p>幂级数在其收敛区间内的基本性质</p><p>简单幂级数的和函数的求法</p><p>初等函数的幂级数展开式</p><p>函数的傅里叶(Fourier)系数与傅里叶级数</p><p>狄利克雷(Dirichlet)定理</p><p>函数在[-ι,ι]上的傅里叶级数</p><p>函数在[0,ι]上的正弦级数和余弦级数.</p><p>考试要求</p><p>1.理解常数项级数收敛、发散以及收敛级数的和的概念，掌握级数的基本性质及收敛的必要条件.</p><p>2.掌握几何级数与级数的收敛与发散的条件.</p><p>3.掌握正项级数收敛性的比较判别法、比值判别法、根值判别法，会用积分判别法.</p><p>4.掌握交错级数的莱布尼茨判别法.</p><p>5.了解任意项级数绝对收敛与条件收敛的概念以及绝对收敛与收敛的关系.</p><p>6.了解函数项级数的收敛域及和函数的概念.</p><p>7.理解幂级数收敛半径的概念、并掌握幂级数的收敛半径、收敛区间及收敛域的求法.</p><p>8.了解幂级数在其收敛区间内的基本性质(和函数的连续性、逐项求导和逐项积分)，会求一些幂级数在收敛区间内的和函数，并会由此求出某些数项级数的和.</p><p>9.了解函数展开为泰勒级数的充分必要条件.</p><p>10.掌握麦克劳林(Maclaurin)展开式，会用它们将一些简单函数间接展开为幂级数.</p><p>11.了解傅里叶级数的概念和狄利克雷收敛定理，会将定义在[-ι,ι]上的函数展开为傅里叶级数，会将定义在[0,ι]上的函数展开为正弦级数与余弦级数，会写出傅里叶级数的和函数的表达式.</p><h2 id="八、常微分方程"><a href="#八、常微分方程" class="headerlink" title="八、常微分方程"></a>八、常微分方程</h2><p>常微分方程的基本概念</p><p>变量可分离的微分方程、齐次微分方程</p><p>一阶线性微分方程</p><p>伯努利(Bernoulli)方程</p><p>全微分方程</p><p>可用简单的变量代换求解的某些微分方程</p><p>可降阶的高阶微分方程</p><p>线性微分方程解的性质及解的结构定理</p><p>二阶常系数齐次线性微分方程</p><p>高于二阶的某些常系数齐次线性微分方程</p><p>简单的二阶常系数非齐次线性微分方程</p><p>欧拉(Euler)方程</p><p>微分方程的简单应用.</p><p>考试要求</p><p>1.了解微分方程及其阶、解、通解、初始条件和特解等概念.</p><p>2.掌握变量可分离的微分方程及一阶线性微分方程的解法.</p><p>3.会解齐次微分方程、伯努利方程和全微分方程，会用简单的变量代换解某些微分方程.</p><p>4.会用降阶法解下列形式的微分方程：y”&#x3D;f(x)、y”&#x3D; f(x,y’)和y”&#x3D;f(y,y’).</p><p>5.理解线性微分方程解的性质及解的结构.</p><p>6.掌握二阶常系数齐次线性微分方程的解法，并会解某些高于二阶的常系数齐次线性微分方程.</p><p>7.会解自由项为多项式、指数函数、正弦函数、余弦函数以及它们的和与积的二阶常系数非齐次线性微分方程.</p><p>8.会解欧拉方程.</p><p>9.会用微分方程解决一些简单的应用问题.</p><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a><strong>线性代数</strong></h1><h2 id="一、行列式"><a href="#一、行列式" class="headerlink" title="一、行列式"></a>一、行列式</h2><p>行列式的概念和基本性质</p><p>行列式按行(列)展开定理</p><p>考试要求</p><p>1.了解行列式的概念，掌握行列式的性质.</p><p>2.会应用行列式的性质和行列式按行(列)展开定理计算行列式.</p><h2 id="二、矩阵"><a href="#二、矩阵" class="headerlink" title="二、矩阵"></a>二、矩阵</h2><p>矩阵的概念</p><p>矩阵的线性运算</p><p>矩阵的乘法</p><p>方阵的幂</p><p>方阵乘积的行列式</p><p>矩阵的转置</p><p>逆矩阵的概念和性质</p><p>矩阵可逆的充分必要条件</p><p>伴随矩阵、矩阵的初等变换</p><p>初等矩阵</p><p>矩阵的秩</p><p>矩阵的等价</p><p>分块矩阵及其运算.</p><p>考试要求</p><p>1.理解矩阵的概念，了解单位矩阵、数量矩阵、对角矩阵、三角矩阵、对称矩阵和反对称矩阵以及它们的性质.</p><p>2.掌握矩阵的线性运算、乘法、转置以及它们的运算规律，了解方阵的幂与方阵乘积的行列式的性质.</p><p>3.理解逆矩阵的概念，掌握逆矩阵的性质以及矩阵可逆的充分必要条件，理解伴随矩阵的概念，会用伴随矩阵求逆矩阵.</p><p>4.理解矩阵初等变换的概念，了解初等矩阵的性质和矩阵等价的概念，理解矩阵的秩的概念，掌握用初等变换求矩阵的秩和逆矩阵的方法.</p><p>5.了解分块矩阵及其运算.</p><h2 id="三、向量"><a href="#三、向量" class="headerlink" title="三、向量"></a>三、向量</h2><p>向量的概念</p><p>向量的线性组合与线性表示</p><p>向量组的线性相关与线性无关</p><p>向量组的极大线性无关组</p><p>等价向量组</p><p>向量组的秩</p><p>向量组的秩与矩阵的秩之间的关系</p><p>向量空间及其相关概念</p><p>n维向量空间的基变换和坐标变换</p><p>过渡矩阵</p><p>向量的内积</p><p>线性无关向量组的正交规范化方法</p><p>规范正交基</p><p>正交矩阵及其性质.</p><p>考试要求</p><p>1.理解n维向量、向量的线性组合与线性表示的概念.</p><p>2.理解向量组线性相关、线性无关的概念，掌握向量组线性相关、线性无关的有关性质及判别法.</p><p>3.理解向量组的极大线性无关组和向量组的秩的概念，会求向量组的极大线性无关组及秩.</p><p>4.理解向量组等价的概念，理解矩阵的秩与其行(列)向量组的秩之间的关系.</p><p>5.了解n维向量空间、子空间、基底、维数、坐标等概念.</p><p>6.了解基变换和坐标变换公式，会求过渡矩阵.</p><p>7.了解内积的概念，掌握线性无关向量组正交规范化的施密特(Schmidt)方法.</p><p>8.了解规范正交基、正交矩阵的概念以及它们的性质.</p><h2 id="四、线性方程组"><a href="#四、线性方程组" class="headerlink" title="四、线性方程组"></a>四、线性方程组</h2><p>线性方程组的克拉默(Cramer)法则</p><p>齐次线性方程组有非零解的充分必要条件</p><p>非齐次线性方程组有解的充分必要条件</p><p>线性方程组解的性质和解的结构</p><p>齐次线性方程组的基础解系和通解</p><p>解空间</p><p>非齐次线性方程组的通解.</p><p>考试要求</p><p>l.会用克拉默法则.</p><p>2.理解齐次线性方程组有非零解的充分必要条件及非齐次线性方程组有解的充分必要条件.</p><p>3.理解齐次线性方程组的基础解系、通解及解空间的概念，掌握齐次线性方程组的基础解系和通解的求法.</p><p>4.理解非齐次线性方程组解的结构及通解的概念.</p><p>5.掌握用初等行变换求解线性方程组的方法.</p><h2 id="五、矩阵的特征值和特征向量"><a href="#五、矩阵的特征值和特征向量" class="headerlink" title="五、矩阵的特征值和特征向量"></a>五、矩阵的特征值和特征向量</h2><p>矩阵的特征值和特征向量的概念及性质</p><p>相似变换及相似矩阵的概念及性质</p><p>矩阵可相似对角化的充分必要条件及相似对角矩阵</p><p>实对称矩阵的特征值</p><p>特征向量及其相似对角矩阵.</p><p>考试要求</p><p>1.理解矩阵的特征值和特征向量的概念及性质，会求矩阵的特征值和特征向量.</p><p>2.理解相似矩阵的概念、性质及矩阵可相似对角化的充分必要条件，掌握将矩阵化为相似对角矩阵的方法.</p><p>3.掌握实对称矩阵的特征值和特征向量的性质.</p><h2 id="六、二次型"><a href="#六、二次型" class="headerlink" title="六、二次型"></a>六、二次型</h2><p>二次型及其矩阵表示</p><p>合同变换与合同矩阵</p><p>二次型的秩</p><p>惯性定理</p><p>二次型的标准形和规范形</p><p>用正交变换和配方法化二次型为标准形</p><p>二次型及其矩阵的正定性.</p><p>考试要求</p><p>1.掌握二次型及其矩阵表示，了解二次型秩的概念，了解合同变换与合同矩阵的概念，了解二次型的标准形、规范形的概念以及惯性定理.</p><p>2.掌握用正交变换化二次型为标准形的方法，会用配方法化二次型为标准形.</p><p>3.理解正定二次型、正定矩阵的概念，并掌握其判别法.</p><h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a><strong>概率论与数理统计</strong></h1><h2 id="一、随机事件和概率"><a href="#一、随机事件和概率" class="headerlink" title="一、随机事件和概率"></a>一、随机事件和概率</h2><p>随机事件与样本空</p><p>事件的关系与运算</p><p>完备事件组</p><p>概率的概念</p><p>概率的基本性质</p><p>古典型概率</p><p>几何型概率</p><p>条件概率</p><p>概率的基本公式</p><p>事件的独立性</p><p>独立重复试验.</p><p>考试要求</p><p>1.了解样本空间(基本事件空间)的概念，理解随机事件的概念，掌握事件的关系及运算.</p><p>2.理解概率、条件概率的概念，掌握概率的基本性质，会计算古典型概率和几何型概率，掌握概率的加法公式、减法公式、乘法公式、全概率公式，以及贝叶斯(Bayes)公式.</p><p>3.理解事件独立性的概念，掌握用事件独立性进行概率计算;理解独立重复试验的概念，掌握计算有关事件概率的方法.</p><h2 id="二、随机变量及其分布"><a href="#二、随机变量及其分布" class="headerlink" title="二、随机变量及其分布"></a>二、随机变量及其分布</h2><p>随机变量</p><p>随机变量分布函数的概念及其性质</p><p>离散型随机变量的概率分布</p><p>连续型随机变量的概率密度</p><p>常见随机变量的分布</p><p>随机变量函数的分布.</p><p>考试要求</p><p>1.理解随机变量的概念，理解分布函数的概念及性质，会计算与随机变量相联系的事件的概率.</p><p>2.理解离散型随机变量及其概率分布的概念，掌握0-1分布、二项分布、几何分布、超几何分布、泊松(Poisson)分布及其应用.</p><p>3.了解泊松定理的结论和应用条件，会用泊松分布近似表示二项分布.</p><p>4.理解连续型随机变量及其概率密度的概念，掌握均匀分布、正态分布、指数分布及其应用，参数为λ（λ&gt;0）的指数分布的概率密度.</p><p>5.会求随机变量函数的分布.</p><h2 id="三、多维随机变量及其分布"><a href="#三、多维随机变量及其分布" class="headerlink" title="三、多维随机变量及其分布"></a>三、多维随机变量及其分布</h2><p>多维随机变量及其分布二维离散型随机变量的概率分布、边缘分布和条件分布</p><p>二维连续型随机变量的概率密度、边缘概率密度和条件密度</p><p>随机变量的独立性和不相关性</p><p>常用二维随机变量的分布</p><p>两个及两个以上随机变量简单函数的分布.</p><p>考试要求</p><p>1.理解多维随机变量的概念，理解多维随机变量的分布的概念和性质，理解二维离散型随机变量的概率分布、边缘分布和条件分布，理解二维连续型随机变量的概率密度、边缘密度和条件密度，会求与二维随机变量相关事件的概率.</p><p>2.理解随机变量的独立性及不相关性的概念，掌握随机变量相互独立的条件.</p><p>3.掌握二维均匀分布，了解二维正态分布的概率密度，理解其中参数的概率意义.</p><p>4.会求两个随机变量简单函数的分布，会求多个相互独立随机变量简单函数的分布.</p><h2 id="四、随机变量的数字特征"><a href="#四、随机变量的数字特征" class="headerlink" title="四、随机变量的数字特征"></a>四、随机变量的数字特征</h2><p>随机变量的数学期望(均值)</p><p>方差、标准差及其性质</p><p>随机变量函数的数学期</p><p>矩、协方差、相关系数及其性质.</p><p>考试要求</p><p>1.理解随机变量数字特征(数学期望、方差、标准差、矩、协方差、相关系数)的概念，会运用数字特征的基本性质，并掌握常用分布的数字特征.</p><p>2.会求随机变量函数的数学期望.</p><h2 id="五、大数定律和中心极限定理"><a href="#五、大数定律和中心极限定理" class="headerlink" title="五、大数定律和中心极限定理"></a>五、大数定律和中心极限定理</h2><p>切比雪夫(Chebyshev)不等式</p><p>切比雪夫大数定律</p><p>伯努利(Bernoulli)大数定律</p><p>辛钦(Khinchine)大数定律</p><p>棣莫弗-拉普拉斯(De Moivre-Laplace)定理</p><p>列维-林德伯格(Levy-Lindberg)定理.</p><p>考试要求</p><p>1.了解切比雪夫不等式.</p><p>2.了解切比雪夫大数定律、伯努利大数定律和辛钦大数定律(独立同分布随机变量序列的大数定律).</p><p>3.了解棣莫弗-拉普拉斯定理(二项分布以正态分布为极限分布)和列维-林德伯格定理(独立同分布随机变量序列的中心极限定理).</p><p>六、数理统计的基本概念</p><p>总体、个体、简单随机样本、统计量、样本均值、样本方差和样本矩、卡方分布、t分布、F分布、分位数、正态总体的常用抽样分布.</p><p>考试要求</p><p>1.理解总体、简单随机样本、统计量、样本均值、样本方差及样本矩的概念.</p><p>2.了解卡方分布、t分布和F分布的概念及性质，了解上侧α分位数的概念并会查表计算.</p><p>3.了解正态总体的常用抽样分布.</p><h2 id="七、参数估计"><a href="#七、参数估计" class="headerlink" title="七、参数估计"></a>七、参数估计</h2><p>点估计的概念</p><p>估计量与估计值</p><p>矩估计法</p><p>最大似然估计法</p><p>估计量的评选标准</p><p>区间估计的概念</p><p>单个正态总体的均值和方差的区间估计</p><p>两个正态总体的均值差和方差比的区间估计.</p><p>考试要求</p><p>1.理解参数的点估计、估计量与估计值的概念.</p><p>2.掌握矩估计法(一阶矩、二阶矩)和最大似然估计法.</p><p>3.了解估计量的无偏性、有效性(最小方差性)和一致性(相合性)的概念，并会验证估计量的无偏性.</p><p>4、理解区间估计的概念，会求单个正态总体的均值和方差的置信区间，会求两个正态总体的均值差和方差比的置信区间.</p><h2 id="八、假设检验"><a href="#八、假设检验" class="headerlink" title="八、假设检验"></a>八、假设检验</h2><p>显著性检</p><p>假设检验的两类错误</p><p>单个及两个正态总体的均值和方差的假设检验.</p><p>考试要求</p><p>1.理解显著性检验的基本思想，掌握假设检验的基本步骤，了解假设检验可能产生的两类错误.</p><p>2.掌握单个及两个正态总体的均值和方差的假设检验.</p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。</title>
      <link href="/2022/03/27/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2022/03/27/%E5%AE%9E%E9%AA%8C/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。"><a href="#将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。" class="headerlink" title="将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。"></a>将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>安装jdk，安装maven，为maven设置阿里或腾讯镜像仓库，用maven编译Helloworld版的java程序</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将基于TCP协议的Client-Server通信程序示例的服务器端程序改造成线程池版。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary: 客户端</span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-03-27 13:51:43</span><br><span class="line"> * @LastEditTime: 2022-03-27 14:48:22</span><br><span class="line"> * @FilePath: \maven01\src\main\java\com\xxx\maven01\EchoClient.java</span><br><span class="line"> */</span><br><span class="line">package com.xxx.maven01;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class EchoClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    </span><br><span class="line">        String userInput = null;</span><br><span class="line">        String echoMessage = null;</span><br><span class="line"></span><br><span class="line">        BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        //目标ip</span><br><span class="line">        Socket socket = new Socket(&quot;192.168.1.105&quot;,8189);</span><br><span class="line">        System.out.println(&quot;Connect to Server&quot;);</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        BufferedReader in = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">        PrintWriter out = new PrintWriter(outputStream);</span><br><span class="line"></span><br><span class="line">        while((userInput = stdIn.readLine() )!=null)&#123;</span><br><span class="line">            out.println(userInput);</span><br><span class="line">            out.flush();</span><br><span class="line">            echoMessage = in.readLine();</span><br><span class="line">            System.out.println(&quot;Echo from server: &quot;+ echoMessage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @summary: 服务器端</span><br><span class="line"> * @Author: Jianxiang Guo</span><br><span class="line"> * @Date: 2022-03-27 13:53:03</span><br><span class="line"> * @LastEditTime: 2022-03-27 15:37:00</span><br><span class="line"> * @FilePath: \maven01\src\main\java\com\xxx\maven01\EchoServer.java</span><br><span class="line"> */</span><br><span class="line">package com.xxx.maven01;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class ServerPool &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    //监听socket</span><br><span class="line">        ServerSocket listenSocket = new ServerSocket(8189);</span><br><span class="line">        Socket socket = null;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        System.out.println(&quot;Server listening at 8189&quot;);</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200,TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5));</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">            socket = listenSocket.accept();</span><br><span class="line">            count++;</span><br><span class="line">            ServerThread thread = new ServerThread(socket);</span><br><span class="line">            executor.execute(thread);</span><br><span class="line">            System.out.println(&quot;The total number of clients is &quot; + count + &quot;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        listenSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ServerThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    Socket socket = null;</span><br><span class="line"></span><br><span class="line">    public ServerThread(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        InputStream is=null;</span><br><span class="line">        InputStreamReader isr=null;</span><br><span class="line">        BufferedReader br=null;</span><br><span class="line">        OutputStream os=null;</span><br><span class="line">        PrintWriter pw=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            isr = new InputStreamReader(is);</span><br><span class="line">            br = new BufferedReader(isr);</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            pw = new PrintWriter(os);</span><br><span class="line">            String info=null;</span><br><span class="line">            while((info=br.readLine())!=null)&#123;</span><br><span class="line">                System.out.println(&quot;Message from client:&quot;+info);</span><br><span class="line">                pw.println(info);</span><br><span class="line">                pw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(pw!=null)</span><br><span class="line">                    pw.close();</span><br><span class="line">                if(os!=null)</span><br><span class="line">                    os.close();</span><br><span class="line">                if(br!=null)</span><br><span class="line">                    br.close();</span><br><span class="line">                if(isr!=null)</span><br><span class="line">                    isr.close();</span><br><span class="line">                if(is!=null)</span><br><span class="line">                    is.close();</span><br><span class="line">                if(socket!=null)</span><br><span class="line">                    socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img src="/img/1.png" alt="实验结果"></p>]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wx-app学习笔记</title>
      <link href="/2022/02/22/%E7%AC%94%E8%AE%B0/wx/"/>
      <url>/2022/02/22/%E7%AC%94%E8%AE%B0/wx/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序知识点记录"><a href="#微信小程序知识点记录" class="headerlink" title="微信小程序知识点记录"></a>微信小程序知识点记录</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。  </p><ul><li><strong>navigationBarBackgroundColor</strong>  导航栏背景颜色，如 #000000</li><li><strong>navigationBarTextStyle</strong>    导航栏标题颜色，仅支持 black &#x2F; white</li><li><strong>navigationBarTitleText</strong> 导航栏标题文字内容</li><li><strong>backgroundColor</strong> 窗口的背景色</li><li><strong>backgroundTextStyle</strong> 下拉 loading 的样式，仅支持 dark &#x2F; light</li><li><strong>enablePullDownRefresh</strong> 是否开启全局的下拉刷新</li></ul><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/tabbar.ce1b3c5b.png" alt="tabBar"></p><h2 id="框架接口"><a href="#框架接口" class="headerlink" title="框架接口"></a>框架接口</h2><h3 id="页面page"><a href="#页面page" class="headerlink" title="页面page"></a>页面page</h3><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view&gt;&#123;&#123;array[0].msg&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: &#x27;init data&#x27;,</span><br><span class="line">    array: [&#123;msg: &#x27;1&#x27;&#125;, &#123;msg: &#x27;2&#x27;&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期回调函数"><a href="#生命周期回调函数" class="headerlink" title="生命周期回调函数"></a>生命周期回调函数</h3><p><strong>onLoad(Object query)</strong><br>页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。<br><strong>onShow()</strong><br>页面显示&#x2F;切入前台时触发。<br><strong>onReady()</strong><br>页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。<br><strong>onHide()</strong><br>页面隐藏&#x2F;切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等</p><h2 id="WXML语法参考"><a href="#WXML语法参考" class="headerlink" title="WXML语法参考"></a>WXML语法参考</h2><h3 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h3><p>wx:for搭配使用wx:key&#x3D;”*this”<br>wx:for&#x3D;”“ wx:key&#x3D;”*this”</p><h3 id="wx-if"><a href="#wx-if" class="headerlink" title="wx:if"></a>wx:if</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt; 3 &lt;/view&gt;</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="scroll-view-可滚动视图区域"><a href="#scroll-view-可滚动视图区域" class="headerlink" title="scroll-view   可滚动视图区域"></a>scroll-view   可滚动视图区域</h3><p>scroll-x&#x2F;y 允许横向&#x2F;纵向滚动  </p><h3 id="swiper-轮播图"><a href="#swiper-轮播图" class="headerlink" title="swiper  轮播图"></a>swiper  轮播图</h3><ul><li>autoplay  是否自动切换</li><li>interval  自动切换时间间隔</li><li>duration  滑动动画时长</li><li>indicator-dots  是否显示面板指示点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    background: [&#x27;demo-text-1&#x27;, &#x27;demo-text-2&#x27;, &#x27;demo-text-3&#x27;],</span><br><span class="line">    indicatorDots: true,</span><br><span class="line">    vertical: false,</span><br><span class="line">    autoplay: false,</span><br><span class="line">    interval: 2000,</span><br><span class="line">    duration: 500</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;swiper indicator-dots=&quot;&#123;&#123;indicatorDots&#125;&#125;&quot;</span><br><span class="line">        autoplay=&quot;&#123;&#123;autoplay&#125;&#125;&quot; interval=&quot;&#123;&#123;interval&#125;&#125;&quot; duration=&quot;&#123;&#123;duration&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;block wx:for=&quot;&#123;&#123;background&#125;&#125;&quot; wx:key=&quot;*this&quot;&gt;</span><br><span class="line">          &lt;swiper-item&gt;</span><br><span class="line">            &lt;view class=&quot;swiper-item &#123;&#123;item&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br><span class="line">          &lt;/swiper-item&gt;</span><br><span class="line">        &lt;/block&gt;</span><br><span class="line">      &lt;/swiper&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="icon-图标组件"><a href="#icon-图标组件" class="headerlink" title="icon 图标组件"></a>icon 图标组件</h3><p><a href="https://www.iconfont.cn/manage/index?manage_type=myprojects&projectId=3182664">阿里图标库</a></p><h3 id="progress-进度条"><a href="#progress-进度条" class="headerlink" title="progress 进度条"></a>progress 进度条</h3><ul><li>percent 百分比0~100</li><li>show-info 在进度条右侧显示百分比</li></ul><h3 id="checkbox-多选项目"><a href="#checkbox-多选项目" class="headerlink" title="checkbox  多选项目"></a>checkbox  多选项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;checkbox-group bindchange=&quot;checkboxChange&quot;&gt;</span><br><span class="line">          &lt;label class=&quot;weui-cell weui-check__label&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;&#123;&#123;item.value&#125;&#125;&quot;&gt;</span><br><span class="line">            &lt;view class=&quot;weui-cell__hd&quot;&gt;</span><br><span class="line">              &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot; checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot;/&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;weui-cell__bd&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">        &lt;/checkbox-group&gt;</span><br></pre></td></tr></table></figure><h3 id="input-输入框"><a href="#input-输入框" class="headerlink" title="input 输入框"></a>input 输入框</h3><ul><li>type 输入数据类型</li><li>value 输入框的初始内容</li><li>password 是否是密码类型</li><li>confirm-type 设置键盘右下角按钮的文字，仅在type&#x3D;’text’时生效</li></ul><h3 id="radio-单选项目"><a href="#radio-单选项目" class="headerlink" title="radio 单选项目"></a>radio 单选项目</h3><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul><li>switchTab  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</li><li>reLaunch 关闭所有页面，打开到应用内的某个页面</li><li>redirectTo 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。</li><li>navigateTo 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。</li></ul><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>open-type&#x3D;”share”</p><h3 id="showToast-显示消息提示框"><a href="#showToast-显示消息提示框" class="headerlink" title="showToast 显示消息提示框"></a>showToast 显示消息提示框</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.showToast(&#123;</span><br><span class="line">  title: &#x27;成功&#x27;,</span><br><span class="line">  icon: &#x27;success&#x27;,</span><br><span class="line">  duration: 2000</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="request-发起-HTTPS-网络请求"><a href="#request-发起-HTTPS-网络请求" class="headerlink" title="request 发起 HTTPS 网络请求"></a><strong>request</strong> 发起 HTTPS 网络请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: &#x27;example.php&#x27;, //仅为示例，并非真实的接口地址</span><br><span class="line">  data: &#123;</span><br><span class="line">    x: &#x27;&#x27;,</span><br><span class="line">    y: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值</span><br><span class="line">  &#125;,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h3><ul><li>setStorageSync 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。</li><li>getStorageSync 从本地缓存中同步获取指定 key 的内容</li></ul><h3 id="获取用户信息。-getUserProfile"><a href="#获取用户信息。-getUserProfile" class="headerlink" title="获取用户信息。 getUserProfile"></a>获取用户信息。 getUserProfile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: false,</span><br><span class="line">    canIUseGetUserProfile: false,</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    if (wx.getUserProfile) &#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        canIUseGetUserProfile: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserProfile(e) &#123;</span><br><span class="line">    // 推荐使用wx.getUserProfile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认</span><br><span class="line">    // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗</span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      desc: &#x27;用于完善会员资料&#x27;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span><br><span class="line">      success: (res) =&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: true</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo(e) &#123;</span><br><span class="line">    // 不推荐使用getUserInfo获取用户信息，预计自2021年4月13日起，getUserInfo将不再弹出弹窗，并直接返回匿名的用户个人信息</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习笔记</title>
      <link href="/2022/02/21/%E7%AC%94%E8%AE%B0/MarkDown/"/>
      <url>/2022/02/21/%E7%AC%94%E8%AE%B0/MarkDown/</url>
      
        <content type="html"><![CDATA[<p>#数量表示标题等级</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h1 id="段落下三个“-x3D-”"><a href="#段落下三个“-x3D-”" class="headerlink" title="段落下三个“&#x3D;”"></a>段落下三个“&#x3D;”</h1><h2 id="段落下三个“-”"><a href="#段落下三个“-”" class="headerlink" title="段落下三个“-”"></a>段落下三个“-”</h2><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个***表示分割线</p><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>强制换行：两个空格<br>加回车</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>“&gt;”区块引用</p><blockquote><p>“&gt;&gt;”嵌套引用</p></blockquote></blockquote><hr><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><pre><code>    void main()        &#123;            printf(&quot;Hello, world.&quot;);        &#125;     代码段缩进四个空格/一个tab</code></pre><p>或围栏代码块三个“~”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, world.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><em>斜体由“**”包裹</em><br><strong>粗体由两个“*”包裹</strong></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表 -加空格</p><ul><li>第一项</li><li>第二项</li><li>第三项<br>有序列表1.2.即可</li></ul><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>[name]（url）<br><a href="https://31vgs.github.io/">我的博客</a></p><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>[name]（url）<br><img src="/img/friend_404.gif" alt="示例"></p><hr><p><code>反引号标记</code></p><hr><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>支持latex </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim_&#123;x \to 0&#125;\frac&#123;sin(t)&#125;&#123;x&#125;=1</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\lim_{x \to 0}\frac{sin(t)}{x}&#x3D;1<br>$$</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Markdown | Less | Pretty</span><br><span class="line">--- | :---: | ---:</span><br><span class="line">*默认左对齐* | `此列剧中` | **此列右对齐**</span><br><span class="line">1 | 2 | 3</span><br><span class="line">11 | 22 | 33</span><br></pre></td></tr></table></figure><table><thead><tr><th>Markdown</th><th align="center">Less</th><th align="right">Pretty</th></tr></thead><tbody><tr><td><em>默认左对齐</em></td><td align="center"><code>此列剧中</code></td><td align="right"><strong>此列右对齐</strong></td></tr><tr><td>1</td><td align="center">2</td><td align="right">3</td></tr><tr><td>11</td><td align="center">22</td><td align="right">33</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/18/%E7%AC%94%E8%AE%B0/hello-world/"/>
      <url>/2022/02/18/%E7%AC%94%E8%AE%B0/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
